(() => {
  function cleanHtml(html){
    const wrap = document.createElement('div');
    wrap.innerHTML = html;

    // ===== Snapshot dos href originais (atributo cru, não resolvido) =====
    const linkHrefs = new WeakMap();
    wrap.querySelectorAll('a').forEach(a => {
      const raw = a.getAttribute('href'); // mantém exatamente o que veio
      if (raw != null) linkHrefs.set(a, raw);
    });

    // 1) UL: remove inline style
    wrap.querySelectorAll('ul[style]').forEach(u => u.removeAttribute('style'));

    // 2) CK bogus spans de listas (preserva conteúdo)
    wrap.querySelectorAll('span.ck-list-bogus-paragraph').forEach(s => {
      const p = s.parentNode;
      while (s.firstChild) p.insertBefore(s.firstChild, s);
      s.remove();
    });

    // 3) Remover <span> mantendo conteúdo
    //    (Se preferir apenas tirar o style de spans, comente este bloco e use o 3b)
    wrap.querySelectorAll('span').forEach(s => {
      const p = s.parentNode;
      while (s.firstChild) p.insertBefore(s.firstChild, s);
      s.remove();
    });

    // 3b) --- alternativa: somente remover style/atributos de <span>, sem deletar a tag ---
    // wrap.querySelectorAll('span').forEach(s => {
    //   s.removeAttribute('style');
    //   s.removeAttribute('lang');
    //   s.removeAttribute('dir');
    // });

    // 4) Remover atributos residuais ruidosos em todos os elementos
    wrap.querySelectorAll('*').forEach(el => {
      el.removeAttribute('style');
      el.removeAttribute('lang');
      el.removeAttribute('dir');
    });

    // ===== Restaurar fielmente os href dos links (evita virar "/../../") =====
    wrap.querySelectorAll('a').forEach(a => {
      if (linkHrefs.has(a)) {
        a.setAttribute('href', linkHrefs.get(a));
      }
    });

    let out = wrap.innerHTML;

    // Correções específicas anteriores
    out = out.replace(/<strong>\s*:\s*&nbsp;\s*<\/strong>/gi, '<strong>: </strong>');
    out = out.replace(/<\/strong>\s*<strong>/gi, '');
    out = out.replace(/<strong>\s*:\s*<\/strong>/gi, '<strong>: </strong>');
    out = out.replace(/&nbsp;/g, ' ');

    // ====== Espaçamento apenas para tags inline ======
    const inline = '(a|strong|em|b|i|u|sup|sub|code|span)';

    // (A) l’ <strong> → l’<strong>
    out = out.replace(new RegExp("([’'])\\s+<" + inline + "\\b", "gi"), "$1<$2");

    // (B) ...chiots<a> → ...chiots <a>
    out = out.replace(new RegExp("([A-Za-zÀ-ÖØ-öø-ÿ0-9])<" + inline + "\\b", "g"), "$1 <$2");

    // (C) </a>sensibles → </a> sensibles
    out = out.replace(new RegExp("</" + inline + ">(?=[A-Za-zÀ-ÖØ-öø-ÿ0-9])", "g"), "</$1> ");

    // (D) Espaço fino antes de pontuação após tag inline
    out = out.replace(/<\/(strong|em|b|i|u)>\s+([:;!?])/g, "</$1>\u00A0$2");

    return out.trim();
  }

  async function processDrupalCKE5(){
    const inst = window.Drupal && Drupal.CKEditor5Instances;
    if (!inst) {
      return { total: 0, changed: 0, reason: 'Drupal.CKEditor5Instances não encontrado' };
    }
    let total = 0, changed = 0;
    const entries = (typeof inst.entries === 'function') ? inst.entries() : Object.entries(inst);
    for (const [key, val] of entries) {
      total++;
      try {
        const editor = await Promise.resolve(val);
        if (!editor || typeof editor.getData !== 'function' || typeof editor.setData !== 'function') continue;
        const before = editor.getData();
        const after  = cleanHtml(before);
        if (before !== after) { editor.setData(after); changed++; }
      } catch (e) {
        console.warn('Falha ao processar editor', key, e);
      }
    }
    return { total, changed };
  }

  async function fallbackEditable(){
    const edits = [...document.querySelectorAll('.ck-editor__editable[contenteditable="true"]')];
    let changed = 0;
    edits.forEach(ed => {
      try {
        const b = ed.innerHTML;
        const a = cleanHtml(b);
        if (b !== a) { ed.innerHTML = a; changed++; }
      } catch(e){}
    });
    return { total: edits.length, changed };
  }

  processDrupalCKE5().then(async r => {
    if (r.total) {
      alert('CKEditor5 (Drupal) processados: ' + r.total + ' | Alterados: ' + r.changed);
      return;
    }
    const fb = await fallbackEditable();
    alert('Fallback (DOM) processados: ' + fb.total + ' | Alterados: ' + fb.changed + (r.reason ? (' | Obs: ' + r.reason) : ''));
  });
})();
