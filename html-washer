(() => {
  function cleanHtml(html){
    const wrap = document.createElement('div');
    wrap.innerHTML = html;

    // 1) UL: remove inline style
    wrap.querySelectorAll('ul[style]').forEach(u => u.removeAttribute('style'));
    // 2) CK bogus spans de listas
    wrap.querySelectorAll('span.ck-list-bogus-paragraph').forEach(s => {
      const p = s.parentNode;
      while (s.firstChild) p.insertBefore(s.firstChild, s);
      s.remove();
    });
    // 3) Remover <span> mantendo conteúdo
    wrap.querySelectorAll('span').forEach(s => {
      const p = s.parentNode;
      while (s.firstChild) p.insertBefore(s.firstChild, s);
      s.remove();
    });
    // 4) Remover atributos residuais ruidosos
    wrap.querySelectorAll('*').forEach(el => {
      el.removeAttribute('style');
      el.removeAttribute('lang');
      el.removeAttribute('dir');
    });

    let out = wrap.innerHTML;

    // Correções específicas anteriores
    out = out.replace(/<strong>\s*:\s*&nbsp;\s*<\/strong>/gi, '<strong>: </strong>');
    out = out.replace(/<\/strong>\s*<strong>/gi, '');
    out = out.replace(/<strong>\s*:\s*<\/strong>/gi, '<strong>: </strong>');
    out = out.replace(/&nbsp;/g, ' ');

    // ====== Espaçamento apenas para tags inline ======
    // conj. de tags inline que vamos tratar
    const inline = '(a|strong|em|b|i|u|sup|sub|code|span)';

    // (A) Remover espaço indevido logo após apóstrofo francês antes de tag inline: l’ <strong> → l’<strong>
    out = out.replace(new RegExp("([’'])\\s+<" + inline + "\\b", "gi"), "$1<$2");

    // (B) Adicionar espaço antes de tag inline se vier colada a letra/número: ...chiots<a> → ...chiots <a>
    out = out.replace(new RegExp("([A-Za-zÀ-ÖØ-öø-ÿ0-9])<" + inline + "\\b", "g"), "$1 <$2");

    // (C) Adicionar espaço depois de fechar tag inline se vier colada a letra/número: </a>sensibles → </a> sensibles
    out = out.replace(new RegExp("</" + inline + ">(?=[A-Za-zÀ-ÖØ-öø-ÿ0-9])", "g"), "</$1> ");

    // (D) Evitar espaço antes de pontuação comum quando bold/link termina antes dela (opcional, suave)
    // </strong> :  → </strong> :  (NBSP fina francesa seria o ideal; aqui só evita inserir espaço a mais)
    // Se quiser a NBSP fina, troque por '\u00A0'
    out = out.replace(/<\/(strong|em|b|i|u)>\s+([:;!?])/g, "</$1>\u00A0$2");

    return out.trim();
  }

  async function processDrupalCKE5(){
    const inst = window.Drupal && Drupal.CKEditor5Instances;
    if (!inst) {
      return { total: 0, changed: 0, reason: 'Drupal.CKEditor5Instances não encontrado' };
    }
    let total = 0, changed = 0;
    const entries = (typeof inst.entries === 'function') ? inst.entries() : Object.entries(inst);
    for (const [key, val] of entries) {
      total++;
      try {
        const editor = await Promise.resolve(val);
        if (!editor || typeof editor.getData !== 'function' || typeof editor.setData !== 'function') continue;
        const before = editor.getData();
        const after  = cleanHtml(before);
        if (before !== after) { editor.setData(after); changed++; }
      } catch (e) {
        console.warn('Falha ao processar editor', key, e);
      }
    }
    return { total, changed };
  }

  async function fallbackEditable(){
    const edits = [...document.querySelectorAll('.ck-editor__editable[contenteditable="true"]')];
    let changed = 0;
    edits.forEach(ed => {
      try {
        const b = ed.innerHTML;
        const a = cleanHtml(b);
        if (b !== a) { ed.innerHTML = a; changed++; }
      } catch(e){}
    });
    return { total: edits.length, changed };
  }

  processDrupalCKE5().then(async r => {
    if (r.total) {
      alert('CKEditor5 (Drupal) processados: ' + r.total + ' | Alterados: ' + r.changed);
      return;
    }
    const fb = await fallbackEditable();
    alert('Fallback (DOM) processados: ' + fb.total + ' | Alterados: ' + fb.changed + (r.reason ? (' | Obs: ' + r.reason) : ''));
  });
})();
