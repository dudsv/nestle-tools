(() => {
  function cleanHtml(html){
    const wrap = document.createElement('div');
    wrap.innerHTML = html;

    // ===== Snapshot dos href originais (atributo cru, não resolvido) =====
    const linkHrefs = new WeakMap();
    wrap.querySelectorAll('a').forEach(a => {
      const raw = a.getAttribute('href'); // mantém exatamente o que veio
      if (raw != null) linkHrefs.set(a, raw);
    });

    // 1) UL: remove inline style
    wrap.querySelectorAll('ul[style]').forEach(u => u.removeAttribute('style'));

    // 2) CK bogus spans de listas (preserva conteúdo)
    wrap.querySelectorAll('span.ck-list-bogus-paragraph').forEach(s => {
      const p = s.parentNode;
      while (s.firstChild) p.insertBefore(s.firstChild, s);
      s.remove();
    });

    // 3) Remover <span> mantendo conteúdo
    //    (Se preferir apenas tirar o style de spans, comente este bloco e use o 3b)
    wrap.querySelectorAll('span').forEach(s => {
      const p = s.parentNode;
      while (s.firstChild) p.insertBefore(s.firstChild, s);
      s.remove();
    });

    // 3b) --- alternativa: somente remover style/atributos de <span>, sem deletar a tag ---
    // wrap.querySelectorAll('span').forEach(s => {
    //   s.removeAttribute('style');
    //   s.removeAttribute('lang');
    //   s.removeAttribute('dir');
    // });

    // 4) Remover atributos residuais ruidosos em todos os elementos
    wrap.querySelectorAll('*').forEach(el => {
      el.removeAttribute('style');
      el.removeAttribute('lang');
      el.removeAttribute('dir');
    });

    // ===== Restaurar fielmente os href dos links (evita virar "/../../") =====
    wrap.querySelectorAll('a').forEach(a => {
      if (linkHrefs.has(a)) {
        a.setAttribute('href', linkHrefs.get(a));
      }
    });

    // ====== Converter DIVs de markdown SCC em <p> ======
wrap.querySelectorAll('div.paragraph-in-scc-markdown-text').forEach(div => {
  const p = document.createElement('p');
  p.innerHTML = div.innerHTML;   // mantém links, strong, etc.
  div.replaceWith(p);
});

// ====== Remover <strong>/<b>/<em> de dentro de headings ======
wrap.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(h => {
  // remove strong/b/em tags dentro do heading, preservando conteúdo
  h.querySelectorAll('strong, b, em, i').forEach(tag => {
    while (tag.firstChild) {
      tag.parentNode.insertBefore(tag.firstChild, tag);
    }
    tag.remove();
  });
});


    let out = wrap.innerHTML;

    // Correções específicas anteriores
    out = out.replace(/<strong>\s*:\s*&nbsp;\s*<\/strong>/gi, '<strong>: </strong>');
    out = out.replace(/<\/strong>\s*<strong>/gi, '');
    out = out.replace(/<strong>\s*:\s*<\/strong>/gi, '<strong>: </strong>');
    out = out.replace(/&nbsp;/g, ' ');

    // ====== Espaçamento apenas para tags inline ======
    const inline = '(a|strong|em|b|i|u|sup|sub|code|span)';

    // (A) l’ <strong> → l’<strong>
    out = out.replace(new RegExp("([’'])\\s+<" + inline + "\\b", "gi"), "$1<$2");

    // (B) ...chiots<a> → ...chiots <a>
    out = out.replace(new RegExp("([A-Za-zÀ-ÖØ-öø-ÿ0-9])<" + inline + "\\b", "g"), "$1 <$2");

    // (C) </a>sensibles → </a> sensibles
    out = out.replace(new RegExp("</" + inline + ">(?=[A-Za-zÀ-ÖØ-öø-ÿ0-9])", "g"), "</$1> ");

    // (D) Espaço fino antes de pontuação após tag inline
    out = out.replace(/<\/(strong|em|b|i|u)>\s+([:;!?])/g, "</$1>\u00A0$2");

    // ====== Converter nós soltos em <p> ======
(function normalizeLooseNodes(wrap){
  const children = [...wrap.childNodes];

  children.forEach(node => {
    // IGNORAR nós já válidos
    if (node.nodeType === 1 && ['P','UL','OL','LI','H1','H2','H3','H4','H5','H6','BLOCKQUOTE'].includes(node.tagName)) {
      return;
    }

    // Ignorar comentários
    if (node.nodeType === 8) return;

    // Texto puro ou whitespace quebrado → virar <p>
    if (node.nodeType === 3) {
      const txt = node.textContent.trim();
      if (txt.length) {
        const p = document.createElement('p');
        p.textContent = txt;
        wrap.insertBefore(p, node);
      }
      wrap.removeChild(node);
      return;
    }

    // DIV com texto direto → virar <p>
    if (node.nodeType === 1 && node.tagName === 'DIV') {
      const txt = node.textContent.trim();
      if (txt.length) {
        const p = document.createElement('p');
        p.innerHTML = node.innerHTML;
        wrap.insertBefore(p, node);
      }
      wrap.removeChild(node);
      return;
    }

    // BR perdido → remover
    if (node.nodeType === 1 && node.tagName === 'BR') {
      node.remove();
    }
  });

})(wrap);


    return out.trim();
  }

  async function processDrupalCKE5(){
    const inst = window.Drupal && Drupal.CKEditor5Instances;
    if (!inst) {
      return { total: 0, changed: 0, reason: 'Drupal.CKEditor5Instances não encontrado' };
    }
    let total = 0, changed = 0;
    const entries = (typeof inst.entries === 'function') ? inst.entries() : Object.entries(inst);
    for (const [key, val] of entries) {
      total++;
      try {
        const editor = await Promise.resolve(val);
        if (!editor || typeof editor.getData !== 'function' || typeof editor.setData !== 'function') continue;
        const before = editor.getData();
        const after  = cleanHtml(before);
        if (before !== after) { editor.setData(after); changed++; }
      } catch (e) {
        console.warn('Falha ao processar editor', key, e);
      }
    }
    return { total, changed };
  }

  async function fallbackEditable(){
    const edits = [...document.querySelectorAll('.ck-editor__editable[contenteditable="true"]')];
    let changed = 0;
    edits.forEach(ed => {
      try {
        const b = ed.innerHTML;
        const a = cleanHtml(b);
        if (b !== a) { ed.innerHTML = a; changed++; }
      } catch(e){}
    });
    return { total: edits.length, changed };
  }

  processDrupalCKE5().then(async r => {
    if (r.total) {
      alert('CKEditor5 (Drupal) processados: ' + r.total + ' | Alterados: ' + r.changed);
      return;
    }
    const fb = await fallbackEditable();
    alert('Fallback (DOM) processados: ' + fb.total + ' | Alterados: ' + fb.changed + (r.reason ? (' | Obs: ' + r.reason) : ''));
  });
})();
