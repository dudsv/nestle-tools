(() => {
  // Alvo EXATO dos botões "Bewerken" dos Paragraphs
  const SEL = 'input[data-drupal-selector^="edit-field-article-lp-components-"][data-drupal-selector$="-top-links-edit-button"]';
  const TIMEOUT_MS = 15000; // aumente se algum item for muito pesado

  // Extrai o índice N a partir de data-drupal-selector ou id
  function getIndexFrom(el) {
    const src = el.getAttribute('data-drupal-selector') || el.id || '';
    const m = src.match(/edit-field-article-lp-components-(\d+)-top-links-edit-button/);
    return m ? parseInt(m[1], 10) : null;
  }

  // Lista {el, idx} visíveis, com idx válido, ordenados por idx ASC
  function listByIndex() {
    const items = [...document.querySelectorAll(SEL)]
      .filter(el => el.offsetParent && !el.disabled)
      .map(el => ({ el, idx: getIndexFrom(el) }))
      .filter(x => Number.isInteger(x.idx));
    items.sort((a,b) => a.idx - b.idx);
    return items;
  }

  function fire(el) {
    try { el.scrollIntoView({ behavior:'smooth', block:'center' }); } catch {}
    // Paragraphs usa 'event: "mousedown"' e 'prevent: "click"' → mandamos ambos
    el.dispatchEvent(new MouseEvent('mousedown', { bubbles:true, cancelable:true, view:window }));
    setTimeout(() => { el.click?.(); }, 80);
  }

  // Espera UMA mudança forte ligada ao clique atual:
  //  - o próprio botão some do DOM, OU
  //  - muda a contagem total de botões válidos, OU
  //  - ciclo jQuery AJAX (send→complete)
  function waitForChange(targetEl, prevCount) {
    return new Promise(resolve => {
      let done = false, tmo;
      const finish = () => {
        if (done) return;
        done = true;
        clearTimeout(tmo);
        try { mo.disconnect(); } catch {}
        if (hasJQ) {
          jQuery(document).off('ajaxSend', onAjaxSend);
          jQuery(document).off('ajaxComplete', onAjaxComplete);
        }
        setTimeout(resolve, 120); // pequeno settle para behaviors
      };

      // Observar apenas a região relevante (wrapper dos LP components)
      const wrapper =
        document.getElementById('field-article-lp-components-add-more-wrapper') ||
        document.querySelector('[id$="field-article-lp-components-add-more-wrapper"]') ||
        document.body;

      const mo = new MutationObserver(() => {
        const nowCount = listByIndex().length;
        if (!document.contains(targetEl) || nowCount !== prevCount) {
          finish();
        }
      });
      mo.observe(wrapper, { childList:true, subtree:true });

      const hasJQ = !!(window.jQuery && jQuery(document).ajaxComplete);
      let seenActive = false;
      const onAjaxSend = () => { seenActive = true; };
      const onAjaxComplete = () => {
        if (seenActive && (!window.jQuery || jQuery.active === 0)) finish();
      };
      if (hasJQ) {
        jQuery(document).on('ajaxSend', onAjaxSend);
        jQuery(document).on('ajaxComplete', onAjaxComplete);
      }

      tmo = setTimeout(finish, TIMEOUT_MS);
    });
  }

  async function run(startFromIdx = null) {
    const done = new Set();
    // se quiser começar de um N específico, defina startFromIdx, senão parte do menor disponível
    while (true) {
      const items = listByIndex();
      if (!items.length) { console.log('[Edit-All por índice] nenhum botão encontrado'); break; }

      // Próximo N = menor idx ainda não processado e >= startFromIdx (se definido)
      const next = items.find(x =>
        !done.has(x.idx) && (startFromIdx == null || x.idx >= startFromIdx)
      );
      if (!next) {
        console.log('[Edit-All por índice] terminado. Processados:', [...done].sort((a,b)=>a-b));
        break;
      }

      const prevCount = items.length;
      console.log(`[Edit-All por índice] abrindo N=${next.idx} (${done.size+1}/${prevCount}) →`, next.el.id || next.el.name);

      fire(next.el);
      await waitForChange(next.el, prevCount);
      done.add(next.idx);
    }
  }

  run(); // ou run(5) para começar do N=5
})();
