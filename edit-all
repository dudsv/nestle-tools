(() => {
  // Seletor abrangente: cobre várias formas que esses botões aparecem
  const SEL = [
    'input.paragraphs-icon-button-edit',
    'button.paragraphs-icon-button-edit',
    'input[data-drupal-selector*="field-article-lp-components-"][data-drupal-selector*="-edit"]',
    'button[data-drupal-selector*="field-article-lp-components-"][data-drupal-selector*="-edit"]',
    'input[id*="field-article-lp-components-"][id*="-edit"]',
    'button[id*="field-article-lp-components-"][id*="-edit"]',
    'input[data-drupal-selector^="edit-field-article-lp-components-"][data-drupal-selector$="-top-links-edit-button"]',
    'input[id^="edit-field-article-lp-components-"][id$="-top-links-edit-button"]'
  ].join(',');

  // Regex para extrair o índice N do botão
  const RX = [
    /field-article-lp-components-(\d+)-(?:top-links-edit-button|edit)(?:-\d+)?$/,
    /edit-field-article-lp-components-(\d+)-(?:top-links-edit-button|edit)(?:-\d+)?$/
  ];

  const TIMEOUT_MS = 15000; // máximo de espera antes de avançar

  // Lista de botões candidatos
  const Q = () => [...document.querySelectorAll(SEL)]
    .filter(e => e.offsetParent && !e.disabled);

  // Extrai o índice N
  function idxOf(e) {
    const s = e.getAttribute('data-drupal-selector') || e.id || e.name || '';
    for (const r of RX) {
      const m = s.match(r);
      if (m) return parseInt(m[1], 10);
    }
    return null;
  }

  // Lista {el, idx}, ordenados por idx asc
  function list() {
    const items = Q()
      .map(el => ({ el, idx: idxOf(el) }))
      .filter(x => Number.isInteger(x.idx));
    items.sort((a, b) => a.idx - b.idx);
    return items;
  }

  // Dispara o clique (mousedown + click)
  function fire(el) {
    try { el.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch {}
    el.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true, view: window }));
    setTimeout(() => { el.click && el.click(); }, 80);
  }

  // Espera uma mudança forte no DOM/AJAX antes de prosseguir
  function wait(target, prevCount) {
    return new Promise(res => {
      let done = false, tmo;

      const finish = () => {
        if (done) return;
        done = true;
        clearTimeout(tmo);
        try { mo.disconnect(); } catch {}
        if (hasJQ) {
          jQuery(document).off('ajaxSend', onSend);
          jQuery(document).off('ajaxComplete', onComp);
        }
        setTimeout(res, 120); // settle
      };

      const wrapper =
        document.getElementById('field-article-lp-components-add-more-wrapper') ||
        document.querySelector('[id$="field-article-lp-components-add-more-wrapper"]') ||
        document.body;

      const mo = new MutationObserver(() => {
        const now = list().length;
        if (!document.contains(target) || now !== prevCount) finish();
      });
      mo.observe(wrapper, { childList: true, subtree: true });

      const hasJQ = !!(window.jQuery && jQuery(document).ajaxComplete);
      let seen = false;
      const onSend = () => { seen = true; };
      const onComp = () => {
        if (seen && (!window.jQuery || jQuery.active === 0)) finish();
      };
      if (hasJQ) {
        jQuery(document).on('ajaxSend', onSend);
        jQuery(document).on('ajaxComplete', onComp);
      }

      tmo = setTimeout(finish, TIMEOUT_MS);
    });
  }

  // Loop sequencial por índice
  async function run() {
    const done = new Set();
    while (true) {
      const items = list();
      if (!items.length) {
        alert('Nenhum botão de editar encontrado.');
        break;
      }
      const next = items.find(x => !done.has(x.idx));
      if (!next) {
        console.log('[edit-all] terminado', Array.from(done).sort((a, b) => a - b));
        break;
      }

      const before = items.length;
      console.log('[edit-all] N=', next.idx, '/', before, '→', next.el.id || next.el.name);

      fire(next.el);
      await wait(next.el, before);
      done.add(next.idx);
    }
  }

  run();
})();
