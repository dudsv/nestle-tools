(() => {
  const UI = (() => {
    const ov = document.createElement('div');
    ov.style.cssText = 'position:fixed;inset:0;z-index:2147483647;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center';

    const bx = document.createElement('div');
    bx.style.cssText = 'background:#fff;max-width:min(980px,96vw);width:min(980px,96vw);border-radius:14px;box-shadow:0 12px 36px rgba(0,0,0,.35);padding:14px;font:13px/1.45 system-ui,Segoe UI,Roboto,Arial';

    bx.innerHTML = `
<div style="display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:6px">
  <b>NPPE – Master Importer</b>
  <div style="opacity:.7">Cole a linha TSV com 16 colunas (SK Breed … SK META DESCRIPTION)</div>
  <button id="nppe-x" style="padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#f5f5f5;cursor:pointer">Fechar</button>
</div>
<textarea id="nppe-tsv" placeholder="Cole aqui a LINHA (com TABs; campos entre aspas podem ter múltiplas linhas)" style="width:100%;height:170px;border:1px solid #ddd;border-radius:8px;padding:10px;resize:vertical;box-sizing:border-box"></textarea>
<div style="display:flex;gap:8px;margin:8px 0 10px;">
  <button id="nppe-parse" style="padding:8px 12px;border:0;border-radius:8px;background:#555;color:#fff;cursor:pointer">Pré-visualizar</button>
  <button id="nppe-run" style="padding:8px 12px;border:0;border-radius:8px;background:#0b5;color:#fff;cursor:pointer">Aplicar em tudo</button>
</div>
<pre id="nppe-out" style="margin:0;white-space:pre-wrap;max-height:300px;overflow:auto;background:#fafafa;border:1px dashed #ddd;padding:8px;border-radius:8px"></pre>
`;
    ov.appendChild(bx);
    document.body.appendChild(ov);
    bx.querySelector('#nppe-x').onclick = () => ov.remove();

    return {
      ov,
      ta: bx.querySelector('#nppe-tsv'),
      out: bx.querySelector('#nppe-out'),
      btnParse: bx.querySelector('#nppe-parse'),
      btnRun: bx.querySelector('#nppe-run')
    };
  })();

  const log = (m) => {
    UI.out.textContent += (UI.out.textContent ? '\n' : '') + m;
  };

  const norm = (s) => String(s ?? '')
    .replace(/[\u200B-\u200D\u2060\uFEFF]/g, '')
    .replace(/\u00A0/g, ' ')
    .replace(/\r\n/g, '\n');

  const enc = (t) => String(t)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  const fire = (el) => {
    if (!el) return;
    el.dispatchEvent(new InputEvent('input', { bubbles: true }));
    el.dispatchEvent(new Event('change', { bubbles: true }));
    el.dispatchEvent(new Event('blur', { bubbles: true }));
  };

  const delay = (ms) => new Promise(r => setTimeout(r, ms));

  const parseTSV = (raw) => {
    raw = norm(raw).trim();
    const out = [];
    let cur = '';
    let q = false;

    for (let i = 0; i < raw.length; i++) {
      const c = raw[i];
      if (c === '"') {
        const nxt = raw[i + 1];
        if (q && nxt === '"') {
          cur += '"';
          i++;
          continue;
        }
        q = !q;
        continue;
      }
      if (!q && c === '\t') {
        out.push(cur);
        cur = '';
        continue;
      }
      cur += c;
    }
    out.push(cur);
    while (out.length < 16) out.push('');
    return out.slice(0, 16).map(s => {
      s = s.replace(/^\n+|\n+$/g, '');
      if (/^['"“„«‘]/.test(s) && /['"”„»’]$/.test(s)) s = s.slice(1, -1).trim();
      return s;
    });
  };

  const select = (q, r = document) => r.querySelector(q);
  const selectAll = (q, r = document) => Array.from(r.querySelectorAll(q));
  const ckPool = () => (window.Drupal && Drupal.CKEditor5Instances) || null;

  const findCKEByTextarea = (ta) => {
    const pool = ckPool();
    if (pool) {
      try {
        const id = ta.getAttribute('data-ckeditor5-id') || ta.dataset.ckeditor5Id;
        if (typeof pool.get === 'function') {
          return pool.get(id) || pool.get(ta.id) || null;
        } else {
          return pool[id] || pool[ta.id] || null;
        }
      } catch (e) {}
    }
    return null;
  };

  const setCKEHtml = (editable, html) => {
    try {
      const ta = editable?.closest('.field--type-text-long,.js-form-item')?.querySelector('textarea.js-text-full[data-ckeditor5-id]');
      const ed = ta ? findCKEByTextarea(ta) : null;

      if (ed?.setData) {
        ed.setData(html);
      } else {
        if (editable) editable.innerHTML = html;
        if (ta) {
          ta.value = html;
          ta.setAttribute('data-editor-value-is-changed', 'true');
        }
      }
      if (ta) fire(ta);
      if (editable) fire(editable);
    } catch (e) {
      console.warn('CK set error', e);
    }
  };

  const toHtml = (raw) => {
    raw = norm(raw);
    if (!raw) return '';
    if (/<\w|<\/\w|<br/gi.test(raw)) return raw;
    const blocks = raw.split(/\n{2,}/).map(x => x.trim()).filter(Boolean);
    return blocks.map(p => '<p>' + enc(p).replace(/\n/g, '<br>') + '</p>').join('');
  };

  /* ---------- ACCORDION OPENNER (com espera) ---------- */
  const accRoot = () => document.querySelector('#edit-field-components-3-subform') || document;
  const accEditors = () => selectAll('.paragraph-widget--c-text textarea.js-text-full[data-ckeditor5-id]', accRoot());

  const waitAccReady = async (timeout = 120000, min = 5) => {
    const t0 = Date.now();
    let last = -1, stable = 0;
    for (;;) {
      const list = accEditors();
      const pool = ckPool();
      let ok = 0;
      list.forEach(ta => {
        const ed = findCKEByTextarea(ta);
        if (ed?.setData) ok++;
      });
      if (list.length >= min && ok >= Math.min(min, list.length)) {
        if (list.length === last) stable++;
        else { stable = 0; last = list.length; }
        if (stable >= 2) break;
      }
      if (Date.now() - t0 > timeout) break;
      await delay(500);
    }
    return accEditors().length;
  };

  const openAccordionsAndWait = async () => {
    try {
      const btns = Array.from(document.querySelectorAll('.paragraphs-icon-button-edit:not(.paragraphs-previewer)'));
      if (!btns.length) {
        log('↗️ Accordion Openner: nenhum botão encontrado');
        return;
      }
      for (let i = 0; i < btns.length; i++) {
        btns[i].dispatchEvent(new Event('mousedown'));
        await delay(4500);
      }
      const n = await waitAccReady(120000, 5);
      log('↗️ Accordion Openner concluído. Editores detectados: ' + n);
    } catch (e) {
      log('⚠️ Accordion Openner: ' + e.message);
    }
  };

  /* ---------- H1 + Description + Machine name ---------- */
  const fillTitleDescMachine = (title, desc, machine) => {
    const titleEl = select('#edit-title-0-value') || select('input[name="title[0][value]"]');
    if (titleEl) { titleEl.value = title || ''; fire(titleEl); }

    const mainEd = select('.ck-editor__editable[aria-label*="main" i]') || select('.ck-editor__editable');
    if (mainEd) setCKEHtml(mainEd, toHtml(desc || ''));

    const mach = select('#edit-field-nppe-bs-machine-name-0-value') || select('input[name="field_nppe_bs_machine_name[0][value]"]');
    if (mach) { mach.value = (machine || ''); fire(mach); }

    log('✅ H1/Description/Machine name');
  };

  /* ---------- Características (checkboxes) ---------- */
 const markCaracteristicas=(block)=>{
  // --- Normalização forte (ignora acentos e pontuação), conforme você pediu ---
  const normStrong = (s)=> (s||'')
    .toString()
    .replace(/^[\s\-–—•]+/g,'')               // remove bullets/traços iniciais
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // tira acentos
    .replace(/[^\p{L}\p{N}\/ ]+/gu,' ')       // preserva letras/numeros + barra + espaço
    .replace(/\s+/g,' ')                      // colapsa espaços
    .trim()
    .toLowerCase();

  const toks=(s)=> normStrong(s).split(' ').filter(w=>w.length>=2);
  const cover=(A,B)=>{ if(!A.length) return 0; const SB=new Set(B); let inter=0; A.forEach(w=>{ if(SB.has(w)) inter++ }); return inter/Math.max(1,A.length) };
  const score=(line,label)=>{
    // 1) exato pós-normalização (muito importante p/ "Nie / Môže potrebovať ..." etc.)
    if(line.key && label.key && (line.key===label.key)) return 1.0001; // leve prioridade acima de 1
    // 2) fallback: contém
    if(line.txt && label.txt && (line.txt.includes(label.txt) || label.txt.includes(line.txt))) return 0.98;
    // 3) fuzzy por tokens (robusto p/ variações)
    return Math.max( cover(toks(line.txt), toks(label.txt)), 0 );
  };

  // --- Coleta de labels de checkbox de forma mais ampla ---
  const containers = [
    ...document.querySelectorAll('#edit-field-nppe-bs-characteristic, .form-checkboxes, fieldset, .js-form-type-checkboxes')
  ];

  const labels=[];                // {input, txt, key, gid}
  const groups=new Map();         // gid -> [inputs]
  let gid=0;

  const pushLabel = (labEl, inputEl)=>{
    const raw = (labEl?.textContent||'').trim();
    if(!raw || !inputEl) return;
    const txt = normStrong(raw);
    const key = txt; // já normalizado forte (ex.: "nie / moze potrebovat vycvik ako spolunazivat s ostatnymi maznacikmi")
    const entry = { input: inputEl, txt, key, gid };
    labels.push(entry);
    if(!groups.has(gid)) groups.set(gid,[]);
    groups.get(gid).push(inputEl);
  };

  containers.forEach(cont=>{
    // itens do Drupal costumam vir como .js-form-item com <input type="checkbox"> e <label for=..>
    cont.querySelectorAll(':scope .js-form-item, :scope .form-item').forEach(item=>{
      const input = item.querySelector('input[type="checkbox"]');
      // headers de grupo às vezes aparecem desabilitados, ou como fieldset titles sem input
      const isHeader = (!input) || input.disabled || item.classList.contains('form-item__label');
      if(isHeader){ gid++; return; }

      // tenta label pelo "for" primeiro; se não houver, pega o mais próximo
      let lab = null;
      if(input && input.id){
        lab = cont.querySelector(`label[for="${CSS.escape(input.id)}"]`) || item.querySelector(`label[for="${CSS.escape(input.id)}"]`);
      }
      if(!lab) lab = item.querySelector('label') || item.closest('label');
      if(!lab) return;

      pushLabel(lab, input);
    });
  });

  const uncheckGroup=(gid,except)=>{
    (groups.get(gid)||[]).forEach(el=>{
      if(el!==except && el.checked && !el.disabled){
        el.checked=false; fire(el);
      }
    });
  };

  // --- Processa cada linha do bloco do usuário ---
  const lines = (block||'').split('\n').map(s=>s.trim()).filter(Boolean);
  let marked=0, missed=[];
  lines.forEach(lineRaw=>{
    const txt = normStrong(lineRaw);
    if(!txt) return;

    // atalho: muitos mapeamentos vêm no formato "A / B"
    const line = { txt, key: txt };

    // escolhe o melhor label desta linha
    let best=null, bestScore=0;
    for(const lb of labels){
      const sc = score(line, lb);
      if(sc>bestScore){ bestScore=sc; best=lb; }
      if(sc>1) break; // 1.0001 (exato) já é suficiente
    }

    if(best && best.input && !best.input.disabled){
      uncheckGroup(best.gid, best.input);
      if(!best.input.checked){
        best.input.checked = true;
        fire(best.input);
      }
      marked++;
    }else{
      missed.push(lineRaw);
    }
  });

  log(`✅ Características marcadas: ${marked}${missed.length? ` | ⚠️ não casou: ${missed.length}`:''}`);
  if(missed.length){
    // log detalhado (truncado) ajuda a ver rapidamente o que ficou de fora
    log('↪︎ Não casaram (preview): ' + missed.slice(0,5).map(s=>s.slice(0,120)).join(' | ') + (missed.length>5?' …':''));
  }
};

  /* ---------- Health warning drop down ---------- */
  const fillHealth = (raw) => {
    raw = norm(raw);
    const lines = raw.split('\n').filter(x => x.trim().length);
    const title = lines.shift()?.trim() || '';
    const bullets = [];
    const paras = [];

    lines.forEach(l => {
      /^\s*[-–—•]\s+/.test(l) ? bullets.push(l.replace(/^\s*[-–—•]\s+/, '')) : paras.push(l);
    });

    const pHtml = paras.length ? ('<p>' + enc(paras.join('\n')).replace(/\n/g, '<br>&nbsp;') + '</p>') : '';
    const ul = bullets.length ? ('<ul>' + bullets.map(v => '<li>' + enc(v) + '<br>&nbsp;</li>').join('') + '</ul>') : '';

    const titleInput =
      select('[data-drupal-selector$="subform-field-health-warning-title-0-value"]') ||
      select('input[name*="[field_health_warning_title]"]');

    const editor =
      select('.field--name-field-health-warning-description .ck-editor__editable[contenteditable]') ||
      select('.ck-editor__editable[contenteditable]');

    const hiddenTA =
      select('textarea[data-drupal-selector$="subform-field-health-warning-description-0-value"]') ||
      select('textarea[name*="[field_health_warning_description]"]');

    if (titleInput) { titleInput.value = title; fire(titleInput); }
    if (editor) {
      setCKEHtml(editor, pHtml + ul);
      if (hiddenTA) {
        hiddenTA.value = pHtml + ul;
        fire(hiddenTA);
      }
    }
    log('✅ Health warning');
  };

  /* ---------- Image+text (Osobnosť & Pôvod) ---------- */
  const fillImageText = (personality, history) => {
    const docs = [document];
    selectAll('iframe').forEach(f => {
      try { f.contentDocument && docs.push(f.contentDocument); } catch (e) {}
    });

    const findBlocks = (doc) =>
      selectAll('.field--name-field-c-sideimagetext-summary', doc).map(w => {
        const ed = w.querySelector('.ck-editor__editable[contenteditable="true"]');
        const ta = w.querySelector('textarea[name*="[field_c_sideimagetext_summary]"][name$="[0][value]"]');
        const html = ed ? ed.innerHTML : (ta ? ta.value : '');
        const m = html.match(/<h2[^>]*>([\s\S]*?)<\/h2>/i);
        const title = m ? m[1].replace(/<[^>]+>/g, '').trim() : '';
        return { doc, wrap: w, ed, ta, titleRaw: m ? m[0] : '', rest: html.replace(m ? m[0] : '', '') };
      });

    const set = (blk, body) => {
      if (!blk) return;
      const html = (blk.titleRaw || '') + toHtml(body || '');
      if (blk.ed) setCKEHtml(blk.ed, html);
      else if (blk.ta) { blk.ta.value = html; fire(blk.ta); }
    };

    let b1 = null, b2 = null;
    docs.forEach(d => {
      findBlocks(d).forEach(b => {
        const t = b.titleRaw.toLowerCase();
        if (/osobn/.test(t)) b1 = b;
        if (/p[oô]vod/.test(t)) b2 = b;
      });
    });

    if (b1) set(b1, personality);
    if (b2) set(b2, history);

    log(`✅ Image+text: ${(b1 ? 'Osobnosť' : '—')}/${(b2 ? 'Pôvod' : '—')}`);
  };

  /* ---------- Accordion (limpa + preenche 5) ---------- */
  const accClear = async () => {
    let api = 0, fb = 0;
    accEditors().forEach(ta => {
      try {
        const ed = findCKEByTextarea(ta);
        if (ed?.setData) {
          ed.setData('');
          api++;
        } else {
          ta.value = '';
          ta.setAttribute('data-editor-value-is-changed', 'true');
          fire(ta);
          const ediv = ta.closest('.field--type-text-long')?.querySelector('.ck-editor__editable');
          if (ediv) ediv.innerHTML = '';
          fb++;
        }
      } catch (e) {}
    });
    await delay(150);
    return { api, fb, tot: accEditors().length };
  };

  const accSetOne = (ta, html) => {
    const ed = findCKEByTextarea(ta);
    if (ed?.setData) {
      ed.setData(html);
    } else {
      const ediv = ta.closest('.field--type-text-long')?.querySelector('.ck-editor__editable');
      if (ediv) ediv.innerHTML = html;
      ta.value = html;
      ta.setAttribute('data-editor-value-is-changed', 'true');
    }
    fire(ta);
  };

  const fillAccordion = async (items) => {
    const info = await accClear();
    log(`↻ Accordion limpo: via API ${info.api} | fallback ${info.fb} | total ${info.tot}`);

    const tas = accEditors();

    const toHtmlAcc = (s) => {
      s = (s || '').trim();
      if (!s) s = '[delete block]';
      const parts = s.split(/\n{2,}/).map(x => x.trim()).filter(Boolean);
      return (parts.length ? parts : [''])
        .map(p => '<p>' + enc(p).replace(/\n/g, '<br>') + '</p>').join('');
    };

    const n = Math.min(items.length, tas.length);
    for (let i = 0; i < n; i++) {
      accSetOne(tas[i], toHtmlAcc(items[i]));
      await delay(40);
    }
    log('✅ Accordion preenchido');
  };

  /* ---------- Quick Links ---------- */
  const fillQuickLinks = (raw) => {
    raw = norm(raw);
    const lines = raw.split('\n').map(x => x.trim()).filter(Boolean);

    const w = (select('[id$="subform-field-c-quicklinks-links-wrapper"]')?.closest('[id^="edit-field-components-"][id$="-subform"]')) || document;
    const t = w.querySelector('textarea[data-drupal-selector*="field-c-quicklinks-title"]') ||
              w.querySelector('input[data-drupal-selector*="field-c-quicklinks-title"]');

    const rows = selectAll('#field-c-quicklinks-links-values tbody tr', w)
      .map(tr => ({
        t: tr.querySelector('input[name$="[title]"]'),
        u: tr.querySelector('input[name$="[uri]"]')
      }))
      .filter(o => o.t && o.u);

    if (t) { t.value = ''; fire(t); }
    rows.forEach(o => {
      o.t.value = ''; o.u.value = '';
      fire(o.t); fire(o.u);
    });

    if (!lines.length) {
      log('✅ Quick Links limpos (sem conteúdo)');
      return;
    }

    const title = lines.shift();
    if (t) { t.value = title || ''; fire(t); }

    let k = 0;
    lines.forEach((ln, i) => {
      if (i >= rows.length) return;
      const m = ln.match(/^([^:]+):\s*(.+)$/);
      if (!m) return;
      rows[i].t.value = m[1].trim();
      rows[i].u.value = m[2].trim();
      fire(rows[i].t); fire(rows[i].u);
      k++;
    });
    log(`✅ Quick Links: título + ${k} link(s)`);
  };

  /* ---------- Meta (URL + Title + Description) ---------- */
  const fillMeta = (alias, mtitle, mdesc) => {
    const elUrl = select('[data-drupal-selector="edit-path-0-alias"]') ||
                  select('#edit-path-0-alias') ||
                  select('input[name="path[0][alias]"]');

    const elTitle = select('[data-drupal-selector="edit-field-meta-tags-0-basic-title"]') ||
                    select('#edit-field-meta-tags-0-basic-title') ||
                    select('input[name="field_meta_tags[0][basic][title]"]');

    const elOgTitle = select('[data-drupal-selector="edit-field-meta-tags-0-open-graph-og-title"]') ||
                      select('#edit-field-meta-tags-0-open-graph-og-title') ||
                      select('input[name="field_meta_tags[0][open_graph][og_title]"]');

    const elDesc = select('[data-drupal-selector="edit-field-meta-tags-0-basic-description"]') ||
                   select('#edit-field-meta-tags-0-basic-description') ||
                   select('textarea[name="field_meta_tags[0][basic][description]"]');

    const elOgDesc = select('[data-drupal-selector="edit-field-meta-tags-0-open-graph-og-description"]') ||
                     select('#edit-field-meta-tags-0-open-graph-og-description') ||
                     select('textarea[name="field_meta_tags[0][open_graph][og_description]"]');

    if (alias && !/^\/|^https?:/i.test(alias)) alias = '/' + alias;

    [
      [elUrl, alias],
      [elTitle, mtitle],
      [elOgTitle, mtitle],
      [elDesc, mdesc],
      [elOgDesc, mdesc]
    ].forEach(([el, v]) => {
      if (el) { el.value = v || ''; fire(el); }
    });

    log('✅ Meta (URL / titles / descriptions)');
  };

  /* ---------- Glue: parse + run ---------- */
  const COLS = [
    'SK Breed',
    'SK DESCRIPTON',
    'SK CHARAKTERISTIC',
    'Machine name',
    'SK HEALTH',
    'SK PERSONALITY',
    'SK HISTORY',
    'Cvičenie',
    'Ideálny majiteľ',
    'Výživa',
    'Starostlivosť o srsť',
    'Vhodnosť pre rodinný život',
    'SK QUICK LINKS',
    'SK URL',
    'SK META TITLE',
    'SK META DESCRIPTION'
  ];

  const preview = (arr) => {
    const kv = COLS.map((k, i) => `• ${k}: ${ (arr[i] || '').slice(0,120).replace(/\n/g, ' ⏎ ') }`);
    UI.out.textContent = 'Pré-visualização (truncada):\n' + kv.join('\n');
  };

  UI.btnParse.onclick = () => {
    const arr = parseTSV(UI.ta.value || '');
    preview(arr);
  };

  UI.btnRun.onclick = async () => {
    UI.out.textContent = '';
    const row = parseTSV(UI.ta.value || '');
    if (row.filter(x => x !== '').length === 0) {
      log('Cole a linha TSV.');
      return;
    }
    preview(row);

    /* 1) Abrir accords e ESPERAR */
    await openAccordionsAndWait();

    /* 2) Preencher demais campos */
    const [
      breed, desc, carac, machine, health,
      personality, history,
      acc1, acc2, acc3, acc4, acc5,
      quicklinks, url, mtitle, mdesc
    ] = row;

    try { fillTitleDescMachine(breed, desc, machine); }
    catch (e) { log('⚠️ H1/Description/Machine: ' + e.message); }

    try { markCaracteristicas(carac); }
    catch (e) { log('⚠️ Características: ' + e.message); }

    try { fillHealth(health); }
    catch (e) { log('⚠️ Health warning: ' + e.message); }

    try { fillImageText(personality, history); }
    catch (e) { log('⚠️ Image+text: ' + e.message); }

    /* 3) Só agora: ACCORDION (limpar + preencher) */
    try { await fillAccordion([acc1, acc2, acc3, acc4, acc5]); }
    catch (e) { log('⚠️ Accordion: ' + e.message); }

    try { fillQuickLinks(quicklinks); }
    catch (e) { log('⚠️ Quick Links: ' + e.message); }

    try { fillMeta(url, mtitle, mdesc); }
    catch (e) { log('⚠️ Meta: ' + e.message); }

    log('🎉 Concluído. Verifique os campos antes de salvar.');
  };

  const sel = window.getSelection && window.getSelection().toString();
  if (sel && /\t/.test(sel)) UI.ta.value = sel;
})();
