(() => {
  const UI = (() => {
    const ov = document.createElement('div');
    ov.style.cssText = 'position:fixed;inset:0;z-index:2147483647;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center';

    const bx = document.createElement('div');
    bx.style.cssText = 'background:#fff;max-width:min(980px,96vw);width:min(980px,96vw);border-radius:14px;box-shadow:0 12px 36px rgba(0,0,0,.35);padding:14px;font:13px/1.45 system-ui,Segoe UI,Roboto,Arial';

    bx.innerHTML = `
<div style="display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:6px">
  <b>NPPE – Master Importer</b>
  <div style="opacity:.7">Cole a linha TSV com 16 colunas (SK Breed … SK META DESCRIPTION)</div>
  <button id="nppe-x" style="padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#f5f5f5;cursor:pointer">Fechar</button>
</div>
<textarea id="nppe-tsv" placeholder="Cole aqui a LINHA (com TABs; campos entre aspas podem ter múltiplas linhas)" style="width:100%;height:170px;border:1px solid #ddd;border-radius:8px;padding:10px;resize:vertical;box-sizing:border-box"></textarea>
<div style="display:flex;gap:8px;margin:8px 0 10px;">
  <button id="nppe-parse" style="padding:8px 12px;border:0;border-radius:8px;background:#555;color:#fff;cursor:pointer">Pré-visualizar</button>
  <button id="nppe-run" style="padding:8px 12px;border:0;border-radius:8px;background:#0b5;color:#fff;cursor:pointer">Aplicar em tudo</button>
</div>
<pre id="nppe-out" style="margin:0;white-space:pre-wrap;max-height:300px;overflow:auto;background:#fafafa;border:1px dashed #ddd;padding:8px;border-radius:8px"></pre>
`;
    ov.appendChild(bx);
    document.body.appendChild(ov);
    bx.querySelector('#nppe-x').onclick = () => ov.remove();

    return {
      ov,
      ta: bx.querySelector('#nppe-tsv'),
      out: bx.querySelector('#nppe-out'),
      btnParse: bx.querySelector('#nppe-parse'),
      btnRun: bx.querySelector('#nppe-run')
    };
  })();

  const log = (m) => {
    UI.out.textContent += (UI.out.textContent ? '\n' : '') + m;
  };

  const norm = (s) => String(s ?? '')
    .replace(/[\u200B-\u200D\u2060\uFEFF]/g, '')
    .replace(/\u00A0/g, ' ')
    .replace(/\r\n/g, '\n');

  const enc = (t) => String(t)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  const fire = (el) => {
    if (!el) return;
    el.dispatchEvent(new InputEvent('input', { bubbles: true }));
    el.dispatchEvent(new Event('change', { bubbles: true }));
    el.dispatchEvent(new Event('blur', { bubbles: true }));
  };

  const delay = (ms) => new Promise(r => setTimeout(r, ms));

  const parseTSV = (raw) => {
    raw = norm(raw).trim();
    const out = [];
    let cur = '';
    let q = false;

    for (let i = 0; i < raw.length; i++) {
      const c = raw[i];
      if (c === '"') {
        const nxt = raw[i + 1];
        if (q && nxt === '"') {
          cur += '"';
          i++;
          continue;
        }
        q = !q;
        continue;
      }
      if (!q && c === '\t') {
        out.push(cur);
        cur = '';
        continue;
      }
      cur += c;
    }
    out.push(cur);
    while (out.length < 16) out.push('');
    return out.slice(0, 16).map(s => {
      s = s.replace(/^\n+|\n+$/g, '');
      if (/^['"“„«‘]/.test(s) && /['"”„»’]$/.test(s)) s = s.slice(1, -1).trim();
      return s;
    });
  };

  const select = (q, r = document) => r.querySelector(q);
  const selectAll = (q, r = document) => Array.from(r.querySelectorAll(q));
  const ckPool = () => (window.Drupal && Drupal.CKEditor5Instances) || null;

  const findCKEByTextarea = (ta) => {
    const pool = ckPool();
    if (pool) {
      try {
        const id = ta.getAttribute('data-ckeditor5-id') || ta.dataset.ckeditor5Id;
        if (typeof pool.get === 'function') {
          return pool.get(id) || pool.get(ta.id) || null;
        } else {
          return pool[id] || pool[ta.id] || null;
        }
      } catch (e) {}
    }
    return null;
  };

  const setCKEHtml = (editable, html) => {
    try {
      const ta = editable?.closest('.field--type-text-long,.js-form-item')?.querySelector('textarea.js-text-full[data-ckeditor5-id]');
      const ed = ta ? findCKEByTextarea(ta) : null;

      if (ed?.setData) {
        ed.setData(html);
      } else {
        if (editable) editable.innerHTML = html;
        if (ta) {
          ta.value = html;
          ta.setAttribute('data-editor-value-is-changed', 'true');
        }
      }
      if (ta) fire(ta);
      if (editable) fire(editable);
    } catch (e) {
      console.warn('CK set error', e);
    }
  };

  const toHtml = (raw) => {
    raw = norm(raw);
    if (!raw) return '';
    if (/<\w|<\/\w|<br/gi.test(raw)) return raw;
    const blocks = raw.split(/\n{2,}/).map(x => x.trim()).filter(Boolean);
    return blocks.map(p => '<p>' + enc(p).replace(/\n/g, '<br>') + '</p>').join('');
  };

  /* ---------- ACCORDION OPENNER (com espera) ---------- */
  const accRoot = () => document.querySelector('#edit-field-components-3-subform') || document;
  const accEditors = () => selectAll('.paragraph-widget--c-text textarea.js-text-full[data-ckeditor5-id]', accRoot());

  const waitAccReady = async (timeout = 120000, min = 5) => {
    const t0 = Date.now();
    let last = -1, stable = 0;
    for (;;) {
      const list = accEditors();
      const pool = ckPool();
      let ok = 0;
      list.forEach(ta => {
        const ed = findCKEByTextarea(ta);
        if (ed?.setData) ok++;
      });
      if (list.length >= min && ok >= Math.min(min, list.length)) {
        if (list.length === last) stable++;
        else { stable = 0; last = list.length; }
        if (stable >= 2) break;
      }
      if (Date.now() - t0 > timeout) break;
      await delay(500);
    }
    return accEditors().length;
  };

  const openAccordionsAndWait = async () => {
    try {
      const btns = Array.from(document.querySelectorAll('.paragraphs-icon-button-edit:not(.paragraphs-previewer)'));
      if (!btns.length) {
        log('↗️ Accordion Openner: nenhum botão encontrado');
        return;
      }
      for (let i = 0; i < btns.length; i++) {
        btns[i].dispatchEvent(new Event('mousedown'));
        await delay(4500);
      }
      const n = await waitAccReady(120000, 5);
      log('↗️ Accordion Openner concluído. Editores detectados: ' + n);
    } catch (e) {
      log('⚠️ Accordion Openner: ' + e.message);
    }
  };

  /* ---------- H1 + Description + Machine name ---------- */
  const fillTitleDescMachine = (title, desc, machine) => {
    const titleEl = select('#edit-title-0-value') || select('input[name="title[0][value]"]');
    if (titleEl) { titleEl.value = title || ''; fire(titleEl); }

    const mainEd = select('.ck-editor__editable[aria-label*="main" i]') || select('.ck-editor__editable');
    if (mainEd) setCKEHtml(mainEd, toHtml(desc || ''));

    const mach = select('#edit-field-nppe-bs-machine-name-0-value') || select('input[name="field_nppe_bs_machine_name[0][value]"]');
    if (mach) { mach.value = (machine || ''); fire(mach); }

    log('✅ H1/Description/Machine name');
  };

  /* ---------- Características (checkboxes) ---------- */
 const markCaracteristicas=(block)=>{
  // normalização agressiva (ignora acentos, pontuação, bullets, múltiplos espaços)
  const norm = (s)=> (s||'').toString()
    .replace(/^[\s\-–—•]+/g,'')
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/[^\p{L}\p{N}\/ ]+/gu,' ')
    .replace(/\s+/g,' ')
    .trim()
    .toLowerCase();

  const tok = (s)=> norm(s).split(' ').filter(w=>w.length>=2);
  const cover=(A,B)=>{ if(!A.length||!B.length) return 0; const SB=new Set(B); let k=0; A.forEach(w=>{ if(SB.has(w)) k++ }); return k/Math.max(1,A.length) };

  // score: exato > contém > fuzzy (overlap)
  const score=(lineKey,labelKey)=>{
    if(!lineKey || !labelKey) return 0;
    if(lineKey===labelKey) return 1.0001;                  // exato (prioridade máxima)
    if(lineKey.includes(labelKey) || labelKey.includes(lineKey)) return 0.98; // contém
    return cover(tok(lineKey), tok(labelKey));             // fuzzy
  };

  // encontra label para um input
  const findLabel = (inp)=>{
    if(inp.id){
      const byFor = document.querySelector(`label[for="${CSS.escape(inp.id)}"]`);
      if(byFor) return byFor;
    }
    // fallback: label ancestral
    return inp.closest('label') || inp.parentElement?.querySelector('label') || null;
  };

  // coleta todos os inputs checkbox/radio
  const inputs = Array.from(document.querySelectorAll('input[type="checkbox"], input[type="radio"]'))
    .filter(i=>!i.disabled);

  // monta lista de opções e grupos
  const options = []; // {input, key, raw, type, group}
  const radioGroups = new Map(); // name -> inputs[]
  const checkboxGroups = new Map(); // groupId -> inputs[] (só p/ eventual uncheck por "grupo visual")

  // group id incremental para checkboxes (baseado no fieldset mais próximo)
  let cbGidSeq = 0;
  const getCbGroup = (inp)=>{
    const fs = inp.closest('fieldset');
    if(fs){
      if(!fs.__gid_cb){ fs.__gid_cb = ++cbGidSeq }
      return fs.__gid_cb;
    }
    const wrap = inp.closest('.js-form-type-checkboxes, .form-checkboxes, .js-form-item, .form-item') || document.body;
    if(!wrap.__gid_cb){ wrap.__gid_cb = ++cbGidSeq }
    return wrap.__gid_cb;
  };

  inputs.forEach(inp=>{
    const lab = findLabel(inp);
    const raw = (lab?.textContent || inp.value || '').trim();
    const key = norm(raw);
    if(!key) return;

    const type = inp.type; // 'checkbox' | 'radio'
    let group = null;

    if(type==='radio'){
      group = inp.name || null;
      if(group){
        if(!radioGroups.has(group)) radioGroups.set(group, []);
        radioGroups.get(group).push(inp);
      }
    }else{
      group = getCbGroup(inp);
      if(!checkboxGroups.has(group)) checkboxGroups.set(group, []);
      checkboxGroups.get(group).push(inp);
    }

    options.push({ input: inp, key, raw, type, group });
  });

  const lines = (block||'').split('\n').map(s=>s.trim()).filter(Boolean);
  let marked=0, missed=[];

  // util: desmarcar todo o grupo (rádio), ou grupo visual (checkbox) se necessário
  const uncheckGroup = (opt)=>{
    if(opt.type==='radio' && opt.group && radioGroups.has(opt.group)){
      radioGroups.get(opt.group).forEach(i=>{ if(i.checked){ i.checked=false; i.dispatchEvent(new Event('change',{bubbles:true})) }});
    }
    // para checkbox, só desmarca se o site usar "mutuamente exclusivas" como checkboxes (raro)
    // if(opt.type==='checkbox' && opt.group && checkboxGroups.has(opt.group)) { ... }
  };

  // para debug de melhores candidatos quando não casar
  const topK = (lineKey, K=3)=>{
    return options
      .map(o=>({ o, sc: score(lineKey, o.key) }))
      .sort((a,b)=>b.sc-a.sc)
      .slice(0,K)
      .map(x=>`${x.sc.toFixed(3)}:${x.o.raw.slice(0,80)}`);
  };

  lines.forEach(line=>{
    const lineKey = norm(line);
    if(!lineKey) return;

    // escolhe melhor opção
    let best=null, bestSc=0;
    for(const opt of options){
      const sc = score(lineKey, opt.key);
      if(sc>bestSc){ bestSc=sc; best=opt }
      if(sc>1) break; // exato encontrado
    }

    if(best && best.input){
      // se for rádio, limpa grupo e marca a escolhida
      if(best.type==='radio') uncheckGroup(best);

      if(!best.input.checked){
        best.input.checked = true;
        // dispara eventos "pegajosos" (alguns formulários só escutam keyup/change)
        best.input.dispatchEvent(new InputEvent('input',{bubbles:true}));
        best.input.dispatchEvent(new Event('change',{bubbles:true}));
        best.input.dispatchEvent(new KeyboardEvent('keyup',{bubbles:true,key:'End'}));
        best.input.dispatchEvent(new Event('blur',{bubbles:true}));
      }
      marked++;
    }else{
      missed.push({ line, suggestions: topK(lineKey) });
    }
  });

  const missCount = missed.length;
  console.log('[Características] Opções coletadas:', options.length, 'Rádios:', radioGroups.size, 'Checkbox grupos:', checkboxGroups.size);
  log(`✅ Características marcadas: ${marked}${missCount? ` | ⚠️ não casou: ${missCount}`:''}`);
  if(missCount){
    // loga no console para debug mais rico; no painel mostramos um resumo curto
    console.groupCollapsed('⚠️ Características não casadas – detalhes');
    missed.forEach(m=>console.log('Linha:', m.line, '\nTop:', m.suggestions.join('  ||  ')));
    console.groupEnd();
    // resumo visível no painel
    log('↪︎ Não casadas (preview): '+ missed.slice(0,3).map(m=>m.line.slice(0,120)).join(' | ') + (missCount>3?' …':''));
  }
};

  /* ---------- Health warning drop down ---------- */
  const fillHealth = (raw) => {
    raw = norm(raw);
    const lines = raw.split('\n').filter(x => x.trim().length);
    const title = lines.shift()?.trim() || '';
    const bullets = [];
    const paras = [];

    lines.forEach(l => {
      /^\s*[-–—•]\s+/.test(l) ? bullets.push(l.replace(/^\s*[-–—•]\s+/, '')) : paras.push(l);
    });

    const pHtml = paras.length ? ('<p>' + enc(paras.join('\n')).replace(/\n/g, '<br>&nbsp;') + '</p>') : '';
    const ul = bullets.length ? ('<ul>' + bullets.map(v => '<li>' + enc(v) + '<br>&nbsp;</li>').join('') + '</ul>') : '';

    const titleInput =
      select('[data-drupal-selector$="subform-field-health-warning-title-0-value"]') ||
      select('input[name*="[field_health_warning_title]"]');

    const editor =
      select('.field--name-field-health-warning-description .ck-editor__editable[contenteditable]') ||
      select('.ck-editor__editable[contenteditable]');

    const hiddenTA =
      select('textarea[data-drupal-selector$="subform-field-health-warning-description-0-value"]') ||
      select('textarea[name*="[field_health_warning_description]"]');

    if (titleInput) { titleInput.value = title; fire(titleInput); }
    if (editor) {
      setCKEHtml(editor, pHtml + ul);
      if (hiddenTA) {
        hiddenTA.value = pHtml + ul;
        fire(hiddenTA);
      }
    }
    log('✅ Health warning');
  };

  /* ---------- Image+text (Osobnosť & Pôvod) ---------- */
  const fillImageText = (personality, history) => {
    const docs = [document];
    selectAll('iframe').forEach(f => {
      try { f.contentDocument && docs.push(f.contentDocument); } catch (e) {}
    });

    const findBlocks = (doc) =>
      selectAll('.field--name-field-c-sideimagetext-summary', doc).map(w => {
        const ed = w.querySelector('.ck-editor__editable[contenteditable="true"]');
        const ta = w.querySelector('textarea[name*="[field_c_sideimagetext_summary]"][name$="[0][value]"]');
        const html = ed ? ed.innerHTML : (ta ? ta.value : '');
        const m = html.match(/<h2[^>]*>([\s\S]*?)<\/h2>/i);
        const title = m ? m[1].replace(/<[^>]+>/g, '').trim() : '';
        return { doc, wrap: w, ed, ta, titleRaw: m ? m[0] : '', rest: html.replace(m ? m[0] : '', '') };
      });

    const set = (blk, body) => {
      if (!blk) return;
      const html = (blk.titleRaw || '') + toHtml(body || '');
      if (blk.ed) setCKEHtml(blk.ed, html);
      else if (blk.ta) { blk.ta.value = html; fire(blk.ta); }
    };

    let b1 = null, b2 = null;
    docs.forEach(d => {
      findBlocks(d).forEach(b => {
        const t = b.titleRaw.toLowerCase();
        if (/osobn/.test(t)) b1 = b;
        if (/p[oô]vod/.test(t)) b2 = b;
      });
    });

    if (b1) set(b1, personality);
    if (b2) set(b2, history);

    log(`✅ Image+text: ${(b1 ? 'Osobnosť' : '—')}/${(b2 ? 'Pôvod' : '—')}`);
  };

  /* ---------- Accordion (limpa + preenche 5) ---------- */
  const accClear = async () => {
    let api = 0, fb = 0;
    accEditors().forEach(ta => {
      try {
        const ed = findCKEByTextarea(ta);
        if (ed?.setData) {
          ed.setData('');
          api++;
        } else {
          ta.value = '';
          ta.setAttribute('data-editor-value-is-changed', 'true');
          fire(ta);
          const ediv = ta.closest('.field--type-text-long')?.querySelector('.ck-editor__editable');
          if (ediv) ediv.innerHTML = '';
          fb++;
        }
      } catch (e) {}
    });
    await delay(150);
    return { api, fb, tot: accEditors().length };
  };

  const accSetOne = (ta, html) => {
    const ed = findCKEByTextarea(ta);
    if (ed?.setData) {
      ed.setData(html);
    } else {
      const ediv = ta.closest('.field--type-text-long')?.querySelector('.ck-editor__editable');
      if (ediv) ediv.innerHTML = html;
      ta.value = html;
      ta.setAttribute('data-editor-value-is-changed', 'true');
    }
    fire(ta);
  };

  const fillAccordion = async (items) => {
    const info = await accClear();
    log(`↻ Accordion limpo: via API ${info.api} | fallback ${info.fb} | total ${info.tot}`);

    const tas = accEditors();

    const toHtmlAcc = (s) => {
      s = (s || '').trim();
      if (!s) s = '[delete block]';
      const parts = s.split(/\n{2,}/).map(x => x.trim()).filter(Boolean);
      return (parts.length ? parts : [''])
        .map(p => '<p>' + enc(p).replace(/\n/g, '<br>') + '</p>').join('');
    };

    const n = Math.min(items.length, tas.length);
    for (let i = 0; i < n; i++) {
      accSetOne(tas[i], toHtmlAcc(items[i]));
      await delay(40);
    }
    log('✅ Accordion preenchido');
  };

  /* ---------- Quick Links ---------- */
  const fillQuickLinks = (raw) => {
    raw = norm(raw);
    const lines = raw.split('\n').map(x => x.trim()).filter(Boolean);

    const w = (select('[id$="subform-field-c-quicklinks-links-wrapper"]')?.closest('[id^="edit-field-components-"][id$="-subform"]')) || document;
    const t = w.querySelector('textarea[data-drupal-selector*="field-c-quicklinks-title"]') ||
              w.querySelector('input[data-drupal-selector*="field-c-quicklinks-title"]');

    const rows = selectAll('#field-c-quicklinks-links-values tbody tr', w)
      .map(tr => ({
        t: tr.querySelector('input[name$="[title]"]'),
        u: tr.querySelector('input[name$="[uri]"]')
      }))
      .filter(o => o.t && o.u);

    if (t) { t.value = ''; fire(t); }
    rows.forEach(o => {
      o.t.value = ''; o.u.value = '';
      fire(o.t); fire(o.u);
    });

    if (!lines.length) {
      log('✅ Quick Links limpos (sem conteúdo)');
      return;
    }

    const title = lines.shift();
    if (t) { t.value = title || ''; fire(t); }

    let k = 0;
    lines.forEach((ln, i) => {
      if (i >= rows.length) return;
      const m = ln.match(/^([^:]+):\s*(.+)$/);
      if (!m) return;
      rows[i].t.value = m[1].trim();
      rows[i].u.value = m[2].trim();
      fire(rows[i].t); fire(rows[i].u);
      k++;
    });
    log(`✅ Quick Links: título + ${k} link(s)`);
  };

  /* ---------- Meta (URL + Title + Description) ---------- */
  const fillMeta = (alias, mtitle, mdesc) => {
    const elUrl = select('[data-drupal-selector="edit-path-0-alias"]') ||
                  select('#edit-path-0-alias') ||
                  select('input[name="path[0][alias]"]');

    const elTitle = select('[data-drupal-selector="edit-field-meta-tags-0-basic-title"]') ||
                    select('#edit-field-meta-tags-0-basic-title') ||
                    select('input[name="field_meta_tags[0][basic][title]"]');

    const elOgTitle = select('[data-drupal-selector="edit-field-meta-tags-0-open-graph-og-title"]') ||
                      select('#edit-field-meta-tags-0-open-graph-og-title') ||
                      select('input[name="field_meta_tags[0][open_graph][og_title]"]');

    const elDesc = select('[data-drupal-selector="edit-field-meta-tags-0-basic-description"]') ||
                   select('#edit-field-meta-tags-0-basic-description') ||
                   select('textarea[name="field_meta_tags[0][basic][description]"]');

    const elOgDesc = select('[data-drupal-selector="edit-field-meta-tags-0-open-graph-og-description"]') ||
                     select('#edit-field-meta-tags-0-open-graph-og-description') ||
                     select('textarea[name="field_meta_tags[0][open_graph][og_description]"]');

    if (alias && !/^\/|^https?:/i.test(alias)) alias = '/' + alias;

    [
      [elUrl, alias],
      [elTitle, mtitle],
      [elOgTitle, mtitle],
      [elDesc, mdesc],
      [elOgDesc, mdesc]
    ].forEach(([el, v]) => {
      if (el) { el.value = v || ''; fire(el); }
    });

    log('✅ Meta (URL / titles / descriptions)');
  };

  /* ---------- Glue: parse + run ---------- */
  const COLS = [
    'SK Breed',
    'SK DESCRIPTON',
    'SK CHARAKTERISTIC',
    'Machine name',
    'SK HEALTH',
    'SK PERSONALITY',
    'SK HISTORY',
    'Cvičenie',
    'Ideálny majiteľ',
    'Výživa',
    'Starostlivosť o srsť',
    'Vhodnosť pre rodinný život',
    'SK QUICK LINKS',
    'SK URL',
    'SK META TITLE',
    'SK META DESCRIPTION'
  ];

  const preview = (arr) => {
    const kv = COLS.map((k, i) => `• ${k}: ${ (arr[i] || '').slice(0,120).replace(/\n/g, ' ⏎ ') }`);
    UI.out.textContent = 'Pré-visualização (truncada):\n' + kv.join('\n');
  };

  UI.btnParse.onclick = () => {
    const arr = parseTSV(UI.ta.value || '');
    preview(arr);
  };

  UI.btnRun.onclick = async () => {
    UI.out.textContent = '';
    const row = parseTSV(UI.ta.value || '');
    if (row.filter(x => x !== '').length === 0) {
      log('Cole a linha TSV.');
      return;
    }
    preview(row);

    /* 1) Abrir accords e ESPERAR */
    await openAccordionsAndWait();

    /* 2) Preencher demais campos */
    const [
      breed, desc, carac, machine, health,
      personality, history,
      acc1, acc2, acc3, acc4, acc5,
      quicklinks, url, mtitle, mdesc
    ] = row;

    try { fillTitleDescMachine(breed, desc, machine); }
    catch (e) { log('⚠️ H1/Description/Machine: ' + e.message); }

    try { markCaracteristicas(carac); }
    catch (e) { log('⚠️ Características: ' + e.message); }

    try { fillHealth(health); }
    catch (e) { log('⚠️ Health warning: ' + e.message); }

    try { fillImageText(personality, history); }
    catch (e) { log('⚠️ Image+text: ' + e.message); }

    /* 3) Só agora: ACCORDION (limpar + preencher) */
    try { await fillAccordion([acc1, acc2, acc3, acc4, acc5]); }
    catch (e) { log('⚠️ Accordion: ' + e.message); }

    try { fillQuickLinks(quicklinks); }
    catch (e) { log('⚠️ Quick Links: ' + e.message); }

    try { fillMeta(url, mtitle, mdesc); }
    catch (e) { log('⚠️ Meta: ' + e.message); }

    log('🎉 Concluído. Verifique os campos antes de salvar.');
  };

  const sel = window.getSelection && window.getSelection().toString();
  if (sel && /\t/.test(sel)) UI.ta.value = sel;
})();
