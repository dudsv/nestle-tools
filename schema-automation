(()=>{'use strict';
/* ===================== Utils base ===================== */
const $=(s,c=document)=>c.querySelector(s);
const norm=s=>(s??'').toString().trim();
function setValue(el,val){ if(!el)return false; const tag=el.tagName.toLowerCase(); el.focus();
  if(tag==='input'||tag==='textarea'||tag==='select'){ el.value=(val==null?'':val); el.dispatchEvent(new Event('input',{bubbles:true})); el.dispatchEvent(new Event('change',{bubbles:true})); return true;}
  return false;
}
function clearValue(el){ return setValue(el,''); }
function pickEl(selectors){ for(const sel of selectors){ const el=$(sel); if(el) return el; } return null; }

/* ===================== Mapeamentos padrão (Purina + FamilyNes) ===================== */
const DEFAULT_MAPPING={
/* ===================== Mapeamentos padrão (Purina + FamilyNes + MX) ===================== */
  // H1 e URL permanecem os mesmos
  h1:     [
    '#edit-title-0-value',
    '[data-drupal-selector="edit-title-0-value"]'
  ],
  url:    [
    '[data-drupal-selector="edit-path-0-alias"]',
    '#edit-path-0-alias'
  ],

  // --- META BASIC (Title/Description) ---
  // 🇲🇽 México (field_meta_tags[0]…) – PRIORIDADE 1
  title:  [
    '[name="field_meta_tags[0][basic][title]"]',
    '#edit-field-meta-tags-0-basic-title',
    '[data-drupal-selector="edit-field-meta-tags-0-basic-title"]',

    // 🇪🇺 Purina/FamilyNes (ln-n-meta-tags…) – fallback
    '#edit-field-ln-n-meta-tags-0-basic-title',
    '[data-drupal-selector="edit-metatags-basic-title"]'
  ],
  desc:   [
    '[name="field_meta_tags[0][basic][description]"]',
    '#edit-field-meta-tags-0-basic-description',
    '[data-drupal-selector="edit-field-meta-tags-0-basic-description"]',

    '#edit-field-ln-n-meta-tags-0-basic-description',
    '[data-drupal-selector="edit-metatags-basic-description"]'
  ],

  // --- OPEN GRAPH (og:title / og:description) ---
  ogtitle:[
    '[name="field_meta_tags[0][open_graph][og_title]"]',
    '#edit-field-meta-tags-0-open-graph-og-title',
    '[data-drupal-selector="edit-field-meta-tags-0-open-graph-og-title"]',

    '#edit-field-ln-n-meta-tags-0-open-graph-og-title',
    '[data-drupal-selector="edit-metatags-open-graph-og-title"]'
  ],
  ogdesc: [
    '[name="field_meta_tags[0][open_graph][og_description]"]',
    '#edit-field-meta-tags-0-open-graph-og-description',
    '[data-drupal-selector="edit-field-meta-tags-0-open-graph-og-description"]',

    '#edit-field-ln-n-meta-tags-0-open-graph-og-description',
    '[data-drupal-selector="edit-metatags-open-graph-og-description"]'
  ]
};


/* ===================== UI ===================== */
const ov=document.createElement('div');
ov.style.cssText='position:fixed;inset:0;z-index:2147483647;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center';
const bx=document.createElement('div');
bx.style.cssText='background:#111;color:#eee;width:min(1060px,96vw);max-height:94vh;overflow:auto;border-radius:14px;box-shadow:0 12px 36px rgba(0,0,0,.4);padding:16px;font:13px/1.45 system-ui,Segoe UI,Roboto,Arial';
bx.innerHTML=`
  <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:10px">
    <b style="font-size:15px">Factory Filler — TSV + Campos Soltos + Schema (v4.1)</b>
    <button id="ff-close" style="padding:6px 10px;border:1px solid #444;border-radius:8px;background:#222;color:#eee">Fechar</button>
  </div>

  <div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:6px">
    <button id="tab-fill"   style="padding:8px 10px;border:1px solid #444;border-radius:8px;background:#2a7;color:#111;font-weight:600">Preenchimento</button>
    <button id="tab-schema" style="padding:8px 10px;border:1px solid #444;border-radius:8px;background:#222;color:#eee">Schema</button>
  </div>

  <!-- Pane de preenchimento convencional -->
  <div id="pane-fill">
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
      <div>
        <div style="opacity:.85;margin-bottom:6px"><b>1) Linha TSV (Excel)</b> — cabeçalho opcional (H1, Title, Desc, URL)</div>
        <textarea id="ff-tsv" placeholder="Cole aqui a LINHA TSV (1 ou 2 linhas: cabeçalho + valores)" style="width:100%;height:120px;background:#181818;color:#ddd;border:1px solid #333;border-radius:10px;padding:10px"></textarea>
        <div style="margin-top:6px;opacity:.7">Se colar só 1 linha, a ordem assumida é: H1, Title, Desc, URL.</div>
      </div>

      <div>
        <div style="opacity:.85;margin-bottom:6px"><b>2) Campos Soltos (opcionais)</b> — sobrescrevem o TSV</div>
        <div style="display:grid;grid-template-columns:1fr;gap:8px">
          <label>H1
            <input id="ff-h1" type="text" placeholder="Ex.: Headline da página" style="width:100%;background:#181818;color:#ddd;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px">
          </label>
          <label>Meta Title
            <input id="ff-title" type="text" placeholder="Ex.: Meta title" style="width:100%;background:#181818;color:#ddd;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px">
          </label>
          <label>Meta Description
            <textarea id="ff-desc" placeholder="Ex.: Meta description" style="width:100%;height:66px;background:#181818;color:#ddd;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px"></textarea>
          </label>
          <label>URL / Alias
            <input id="ff-url" type="text" placeholder="/meu-alias" style="width:100%;background:#181818;color:#ddd;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px">
          </label>

          <div style="display:flex;gap:16px;align-items:center;margin-top:6px">
            <label style="display:flex;gap:6px;align-items:center;">
              <input id="ff-sync-og-title" type="checkbox"> <span>OG Title = Meta Title</span>
            </label>
            <label style="display:flex;gap:6px;align-items:center;">
              <input id="ff-sync-og-desc" type="checkbox"> <span>OG Description = Meta Description</span>
            </label>
          </div>

          <label>OG Title
            <input id="ff-ogtitle" type="text" placeholder="(ou herdado do Meta Title)" style="width:100%;background:#181818;color:#bbb;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px">
          </label>
          <label>OG Description
            <textarea id="ff-ogdesc" placeholder="(ou herdado do Meta Description)" style="width:100%;height:66px;background:#181818;color:#bbb;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px"></textarea>
          </label>
        </div>
      </div>
    </div>

    <details style="margin-top:10px">
      <summary style="cursor:pointer;opacity:.9"><b>Opcional: Mapping JSON</b> (sobrescreve/expande seletores Purina/FamilyNes)</summary>
      <textarea id="ff-json" placeholder='Cole o JSON exportado (com "items": [...])' style="width:100%;height:120px;background:#181818;color:#ddd;border:1px solid #333;border-radius:10px;padding:10px;margin-top:8px"></textarea>
    </details>

    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="ff-run"  style="padding:10px 14px;border:1px solid #444;border-radius:10px;background:#2a7;color:#111;font-weight:600">Preencher</button>
      <button id="ff-dry"  style="padding:10px 14px;border:1px solid #444;border-radius:10px;background:#555;color:#eee;">Só simular</button>
      <button id="ff-clear"style="padding:10px 14px;border:1px solid #444;border-radius:10px;background:#222;color:#eee;">Limpar campos mapeados</button>
    </div>

    <pre id="ff-out" style="margin-top:12px;background:#0d0d0d;border:1px solid #222;border-radius:10px;padding:10px;white-space:pre-wrap"></pre>
  </div>

  <!-- Pane de Schema (apenas campo + botão aplicar, usando SEU MAP) -->
  <div id="pane-schema" style="display:none">
    <div style="opacity:.85;margin-bottom:6px"><b>Schema JSON-LD</b> — cole o JSON (puro) ou o bloco &lt;script type="application/ld+json"&gt;…</div>
    <div id="sch-types" style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 6px">
    <button id="sch-type-article"  style="padding:6px 10px;border:1px solid #444;border-radius:8px;background:#2a7;color:#111;font-weight:600">Articles</button>
    <button id="sch-type-products" style="padding:6px 10px;border:1px solid #444;border-radius:8px;background:#222;color:#eee">Products</button>
    <button id="sch-type-recipes"  style="padding:6px 10px;border:1px solid #444;border-radius:8px;background:#222;color:#eee">Recipes</button>
    </div>

    <textarea id="sch-json" placeholder='Cole aqui…' style="width:100%;min-height:240px;background:#181818;color:#ddd;border:1px solid #333;border-radius:10px;padding:10px;"></textarea>

    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="sch-apply" style="padding:10px 14px;border:1px solid #444;border-radius:10px;background:#2a7;color:#111;font-weight:600">Aplicar Schema</button>
    </div>

    <pre id="sch-log" style="margin-top:12px;background:#0d0d0d;border:1px solid #222;border-radius:10px;padding:10px;white-space:pre-wrap;max-height:28vh;overflow:auto"></pre>
  </div>
`;
ov.appendChild(bx); document.body.appendChild(ov);
$('#ff-close').onclick=()=>ov.remove();

/* ===================== Tabs ===================== */
function showFill(){ $('#pane-fill').style.display=''; $('#pane-schema').style.display='none';
  $('#tab-fill').style.background='#2a7'; $('#tab-fill').style.color='#111';
  $('#tab-schema').style.background='#222'; $('#tab-schema').style.color='#eee';
}
function showSchema(){ $('#pane-fill').style.display='none'; $('#pane-schema').style.display='';
  $('#tab-schema').style.background='#2a7'; $('#tab-schema').style.color='#111';
  $('#tab-fill').style.background='#222'; $('#tab-fill').style.color='#eee';
}
$('#tab-fill').onclick=showFill; $('#tab-schema').onclick=showSchema;

/* ===================== Preenchimento (TSV + Campos) ===================== */
function parseTSV(text){
  const lines=norm(text).split(/\r?\n/).filter(Boolean);
  if(!lines.length) return {};
  let headers=[],values=[];
  if(lines.length===1){ values=lines[0].split('\t'); headers=['H1','Title','Desc','URL']; }
  else{ headers=lines[0].split('\t'); values=lines[1].split('\t'); }
  const raw={}; headers.forEach((h,i)=>raw[h.trim()]=(values[i]||'').trim());
  const out={};
  for(const [k,v] of Object.entries(raw)){
    const kk=k.toLowerCase();
    if(/(^|\s)h1($|\s)/.test(kk)) out.h1=v;
    else if(kk.includes('meta title')||kk==='title') out.title=v;
    else if(kk.includes('meta description')||kk==='desc'||kk==='description') out.desc=v;
    else if(kk==='url'||kk==='alias'||kk==='path'||kk==='slug') out.url=v;
    else if(kk.includes('og')&&kk.includes('title')) out.ogtitle=v;
    else if(kk.includes('og')&&(kk.includes('desc')||kk.includes('description'))) out.ogdesc=v;
  }
  return out;
}
function getManualValues(){return{
  h1:norm($('#ff-h1').value), title:norm($('#ff-title').value), desc:norm($('#ff-desc').value),
  url:norm($('#ff-url').value), ogtitle:norm($('#ff-ogtitle').value), ogdesc:norm($('#ff-ogdesc').value)
};}
function mergePayload(tsv,man,syncT,syncD){ const p={...tsv};
  for(const k of ['h1','title','desc','url','ogtitle','ogdesc']) if(man[k]) p[k]=man[k];
  if(syncT) p.ogtitle=p.title||''; if(syncD) p.ogdesc=p.desc||'';
  return p;
}
function buildSelectorPoolFromJSON(jsonText){
  const pool=JSON.parse(JSON.stringify(DEFAULT_MAPPING));
  if(!jsonText||!jsonText.trim()) return pool;
  try{
    const data=JSON.parse(jsonText); const items=Array.isArray(data.items)?data.items:[];
    const push=(key,sel)=>{ if(sel && !pool[key].includes(sel)) pool[key].push(sel); };
    for(const it of items){
      const label=(it.field?.label||'').toLowerCase(); const note=(it.note||'').toLowerCase();
      const sel=it.field?.cssSelector||(it.field?.id?('#'+it.field.id):null); if(!sel) continue;
      if(note.includes('recebe o h1')||['titulo','título','title'].includes(label)) push('h1',sel);
if(note.includes('meta title')||label==='page title'||note.trim()==='title') push('title',sel);
if(note.includes('meta description')||label==='description'||note.trim()==='desc') push('desc',sel);
if(note.includes('og title')||note.trim()==='ogtitle') push('ogtitle',sel);
if(note.includes('og description')||note.trim()==='ogdesc') push('ogdesc',sel);
if(label.includes('alias')||note.includes('alias')||note.includes('url')) push('url',sel);

    }
  }catch{}
  return pool;
}
function fillFields(payload,selectorPool,{dryRun=false,doClear=false}={}){
  const report={filled:[],skipped:[],missing:[]};
  const keys=['h1','title','desc','ogtitle','ogdesc','url'];
  for(const key of keys){
    const sels=selectorPool[key]||[]; const el=pickEl(sels);
    const hasVal=Object.prototype.hasOwnProperty.call(payload,key)&&payload[key]!==''&&payload[key]!=null;
    const labelHint=(sels[0]||'(nenhum)');
    if(!el){ if(hasVal) report.missing.push({key,selector:labelHint}); continue; }
    if(doClear && !hasVal){ if(!dryRun) clearValue(el); report.filled.push({key,selector:labelHint,value:''}); continue; }
    if(hasVal){ if(!dryRun) setValue(el,payload[key]); report.filled.push({key,selector:labelHint,value:payload[key]}); }
    else{ report.skipped.push({key,selector:labelHint}); }
  }
  return report;
}
function fmtReport(rep){
  const L=[];
  if(rep.filled.length){ L.push('✅ Preenchidos:'); rep.filled.forEach(x=>L.push(`  • ${x.key} → ${x.selector}\n    ↳ ${x.value}`)); }
  if(rep.skipped.length){ L.push('\n⏭️ Ignorados (sem valor):'); rep.skipped.forEach(x=>L.push(`  • ${x.key} → ${x.selector}`)); }
  if(rep.missing.length){ L.push('\n⚠️ Campo não encontrado (nenhum seletor válido no DOM):'); rep.missing.forEach(x=>L.push(`  • ${x.key} (ex.: ${x.selector})`)); }
  return L.join('\n');
}
const outEl=$('#ff-out');
const titleEl=$('#ff-title'),descEl=$('#ff-desc'),ogtEl=$('#ff-ogtitle'),ogdEl=$('#ff-ogdesc'),cSyncT=$('#ff-sync-og-title'),cSyncD=$('#ff-sync-og-desc');
function syncOGTitle(){ if(cSyncT.checked){ ogtEl.value=titleEl.value; ogtEl.disabled=true; ogtEl.style.opacity=.6; } else { ogtEl.disabled=false; ogtEl.style.opacity=1; } }
function syncOGDesc(){ if(cSyncD.checked){ ogdEl.value=descEl.value; ogdEl.disabled=true; ogdEl.style.opacity=.6; } else { ogdEl.disabled=false; ogdEl.style.opacity=1; } }
cSyncT.addEventListener('change',syncOGTitle); cSyncD.addEventListener('change',syncOGDesc);
titleEl.addEventListener('input',syncOGTitle); descEl.addEventListener('input',syncOGDesc);
syncOGTitle(); syncOGDesc();

function getPayloadAndMap(){ const tsv=parseTSV($('#ff-tsv').value); const manual=getManualValues();
  const data=mergePayload(tsv,manual,cSyncT.checked,cSyncD.checked);
  const pool=buildSelectorPoolFromJSON($('#ff-json').value);
  return {data,pool};
}
$('#ff-run').onclick=()=>{ const {data,pool}=getPayloadAndMap(); const rep=fillFields(data,pool,{dryRun:false}); outEl.textContent=fmtReport(rep); };
$('#ff-dry').onclick=()=>{ const {data,pool}=getPayloadAndMap(); const rep=fillFields(data,pool,{dryRun:true}); outEl.textContent='[Simulação]\n'+fmtReport(rep); };
$('#ff-clear').onclick=()=>{ const {pool}=getPayloadAndMap(); const rep=fillFields({},pool,{doClear:true}); outEl.textContent='[Limpeza]\n'+fmtReport(rep); };

/* ===================== Schema (usando seu MAP e setField por name=) ===================== */
const SLOG=$('#sch-log');
// ===================== Schema Name Index (suporta dumps "items") =====================
let SCHEMA_NAME_INDEX = Object.create(null); // token -> { name, css, id }

function normalizeToken(tokens) {
  // tokens -> ancora em schema_article | schema_product | schema_recipe e retorna o restante como token
  if (!Array.isArray(tokens)) return null;
  let i = tokens.indexOf('schema_article');
  if (i < 0) i = tokens.indexOf('schema_product');
  if (i < 0) i = tokens.indexOf('schema_recipe');
  if (i < 0) i = 0;
  const slice = tokens.slice(i);
  if (slice.length >= 2) {
    const head = (slice[0] === 'schema_article' || slice[0] === 'schema_product' || slice[0] === 'schema_recipe')
      ? slice.slice(1) : slice;
    return head.join('.'); // ex.: "schema_recipe_author.@type"
  }
  return null;
}


function updateSchemaNameIndexFromItems(jsonText) {
  try {
    const data = JSON.parse(jsonText);
    if (!data || !Array.isArray(data.items)) return false;
    let count = 0;
    data.items.forEach(it => {
      const name = it?.field?.name;
      const css  = it?.field?.cssSelector || it?.field?.wrapperSelector;
      const id   = it?.field?.id;
      const tokens = it?.drupal?.nameTokens;
      const token = normalizeToken(tokens);
      if (token && (name || css)) {
        SCHEMA_NAME_INDEX[token] = { name, css, id };
        count++;
      }
    });
    slog(`Mapa de Schema/Meta carregado (${count} itens).`, 'ok');
    return count > 0;
  } catch (e) {
    return false;
  }
}

// Tenta variantes do mesmo "name" (metatags[...] -> field_meta_tags[0][...])
function guessNameVariant(originalName) {
  if (!originalName) return null;
  // ex: metatags[schema_article][schema_article_type]
  // -> field_meta_tags[0][schema_article][schema_article_type]
  const m = originalName.match(/^metatags\[(.+?)\]\[(.+?)\]$/) ||
            originalName.match(/^metatags\[(.+?)\]\[(.+?)\]\[(.+?)\]$/) ||
            originalName.match(/^metatags\[(.+?)\]\[(.+?)\]\[(.+?)\]\[(.+?)\]$/);
  if (!m) return null;
  const parts = originalName
    .replace(/^metatags\[/, 'field_meta_tags[0][')
    .replace(/\]\[/g, '][');
  return parts;
}

// Busca elemento por: name exato → name variante → CSS de token → id → última tentativa por endsWith
function findElByAny({ name, token }) {
  let sel, el;
  if (name) {
    sel = `[name="${name.replace(/"/g, '\\"')}"]`;
    el = document.querySelector(sel);
    if (el) return el;

    const v = guessNameVariant(name);
    if (v) {
      sel = `[name="${v.replace(/"/g, '\\"')}"]`;
      el = document.querySelector(sel);
      if (el) return el;
    }
  }
  if (token && SCHEMA_NAME_INDEX[token]) {
    const info = SCHEMA_NAME_INDEX[token];
    if (info.name) {
      sel = `[name="${info.name.replace(/"/g, '\\"')}"]`;
      el = document.querySelector(sel);
      if (el) return el;
    }
    if (info.css) {
      el = document.querySelector(info.css);
      if (el) return el;
    }
    if (info.id) {
      el = document.getElementById(info.id);
      if (el) return el;
    }
  }
  // fallback: qualquer input/select cujo name termine com o sufixo do original
  if (name) {
    const short = name.replace(/^metatags\[/, '').replace(/\]$/,'');
    const candidates = document.querySelectorAll('input[name],textarea[name],select[name]');
    for (const c of candidates) {
      if ((c.name || '').endsWith(short)) return c;
    }
  }
  return null;
}

const slog=(m,cls='')=>{ SLOG.textContent+= (cls?`[${cls}] `:'') + m + '\n'; SLOG.scrollTop=SLOG.scrollHeight; };

// === funções do seu snippet (adaptadas só para usar IDs locais) ===
const APP_ID='schema-json-fill'; // apenas p/ manter nomes

// Tipo atual de schema (Article, Products, Recipes)
let CURRENT_SCHEMA_TYPE = 'article';

// ===================== Schema Maps =====================

// (Opcional) Enum de tipos para evitar typos
const SCHEMA_TYPES = {
  ARTICLE:  'article',
  PRODUCTS: 'products',
  RECIPES:  'recipes',
};

// --- MAP: Article (seu atual, intacto) ---
const ARTICLE_MAP = [
  { path:'@type',                  name:'metatags[schema_article][schema_article_type]',                          type:'select', token:'schema_article_type' },
  { path:'mainEntityOfPage.@id',   name:'metatags[schema_article][schema_article_main_entity_of_page]',                                token:'schema_article_main_entity_of_page' },
  { path:'headline',               name:'metatags[schema_article][schema_article_headline]',                                           token:'schema_article_headline' },
  { path:'description',            name:'metatags[schema_article][schema_article_description]',                                        token:'schema_article_description' },
  { path:'image.@type',            name:'metatags[schema_article][schema_article_image][@type]',                type:'select',          token:'schema_article_image.@type' },
  { path:'image.url',              name:'metatags[schema_article][schema_article_image][url]',                                        token:'schema_article_image.url' },
  { path:'datePublished',          name:'metatags[schema_article][schema_article_date_published]',                                    token:'schema_article_date_published' },
  { path:'publisher.@type',        name:'metatags[schema_article][schema_article_publisher][@type]',           type:'select',          token:'schema_article_publisher.@type' },
  { path:'publisher.name',         name:'metatags[schema_article][schema_article_publisher][name]',                                    token:'schema_article_publisher.name' },
  { path:'publisher.logo.@type',   name:'metatags[schema_article][schema_article_publisher][logo][@type]',     type:'select',          token:'schema_article_publisher.logo.@type' },
  { path:'publisher.logo.url',     name:'metatags[schema_article][schema_article_publisher][logo][url]',                               token:'schema_article_publisher.logo.url' },

  // opcionais + fallbacks
  { path:'@id',                    name:'metatags[schema_article][schema_article_id]',                                                 token:'schema_article_id' },
  { path:'name',                   name:'metatags[schema_article][schema_article_name]',                                               token:'schema_article_name' },
];

// --- MAP: Products (do seu dump) ---
const PRODUCTS_MAP = [
  // raiz
  { path:'@type',        name:'metatags[schema_product][schema_product_type]',                                   type:'select', token:'schema_product_type' },
  { path:'name',         name:'metatags[schema_product][schema_product_name]',                                                  token:'schema_product_name' },
  { path:'description',  name:'metatags[schema_product][schema_product_description]',                                           token:'schema_product_description' },
  { path:'url',          name:'metatags[schema_product][schema_product_url]',                                                   token:'schema_product_url' },

  // image
  { path:'image.@type',  name:'metatags[schema_product][schema_product_image][@type]',                       type:'select',     token:'schema_product_image.@type' },
  { path:'image.url',    name:'metatags[schema_product][schema_product_image][url]',                                          token:'schema_product_image.url' },

  // brand
  { path:'brand.@type',  name:'metatags[schema_product][schema_product_brand][@type]',                       type:'select',     token:'schema_product_brand.@type' },
  { path:'brand.name',   name:'metatags[schema_product][schema_product_brand][name]',                                         token:'schema_product_brand.name' },

  // aggregateRating
  { path:'aggregateRating.@type',       name:'metatags[schema_product][schema_product_aggregate_rating][@type]', type:'select', token:'schema_product_aggregate_rating.@type' },
  { path:'aggregateRating.ratingValue', name:'metatags[schema_product][schema_product_aggregate_rating][ratingValue]',        token:'schema_product_aggregate_rating.ratingValue' },
  { path:'aggregateRating.ratingCount', name:'metatags[schema_product][schema_product_aggregate_rating][ratingCount]',        token:'schema_product_aggregate_rating.ratingCount' },
];

// --- MAP: Recipes ---
const RECIPES_MAP = [
  // raiz
  { path:'@type',           name:'metatags[schema_recipe][schema_recipe_type]',                 type:'select', token:'schema_recipe_type' },
  { path:'name',            name:'metatags[schema_recipe][schema_recipe_name]',                               token:'schema_recipe_name' },
  { path:'description',     name:'metatags[schema_recipe][schema_recipe_description]',                        token:'schema_recipe_description' },
  { path:'datePublished',   name:'metatags[schema_recipe][schema_recipe_date_published]',                     token:'schema_recipe_date_published' },

  // ingredientes (array no JSON)
  { path:'recipeIngredient', name:'metatags[schema_recipe][schema_recipe_recipe_ingredient]',                 token:'schema_recipe_recipe_ingredient' },

  // autor
  { path:'author.@type',    name:'metatags[schema_recipe][schema_recipe_author][@type]',        type:'select', token:'schema_recipe_author.@type' },
  { path:'author.name',     name:'metatags[schema_recipe][schema_recipe_author][name]',                      token:'schema_recipe_author.name' },

  // instruções (string longa)
  { path:'recipeInstructions', name:'metatags[schema_recipe][schema_recipe_recipe_instructions]',            token:'schema_recipe_recipe_instructions' },
];


// Dicionário final dos mapas por tipo
const MAPS = {
  [SCHEMA_TYPES.ARTICLE]:  ARTICLE_MAP,
  [SCHEMA_TYPES.PRODUCTS]: PRODUCTS_MAP,
  [SCHEMA_TYPES.RECIPES]:  RECIPES_MAP,
};

function sanitizeText(v){ if(typeof v!=='string') return v;
  return v.replace(/[\u201C\u201D\u201E\u201F\u2033]/g,'"').replace(/[\u2018\u2019\u2032]/g,"'")
    .replace(/\s+/g,' ').replace(/^\s*["“]|["”]\s*$/g,'').trim();
}
function getByPath(obj,path){ if(!obj||!path) return undefined; return path.split('.').reduce((acc,key)=>acc&&acc[key],obj); }

// extrai JSON do textarea (aceita script ld+json e CSV com aspas duplas)
function extractJsonText(raw){
  let txt=(raw||'').trim().replace(/^\uFEFF/,'');
  if(txt.startsWith('"')&&txt.endsWith('"')){ const inner=txt.slice(1,-1); if((inner.match(/""/g)||[]).length>=1){ txt=inner.replace(/""/g,'"'); slog('Detectei CSV/Excel com aspas — normalizado.','ok'); } }
  if(/<script[^>]*application\/ld\+json/i.test(txt)){
    const m=txt.match(/<script[^>]*application\/ld\+json[^>]*>([\s\S]*?)<\/script>/i);
    if(m&&m[1]){ txt=m[1].trim(); slog('Removi wrapper <script type="application/ld+json">.','ok'); }
    else{ try{ const doc=new DOMParser().parseFromString(txt,'text/html'); const el=doc.querySelector('script[type="application/ld+json"]'); if(el&&el.textContent){ txt=el.textContent.trim(); slog('Extraí JSON-LD via DOMParser.','ok'); } }catch{}
    }
  }
  return txt.trim();
}

function setFieldByName(name, value, kind, token=null){
  const el = findElByAny({ name, token });
  if(!el){ slog(`não encontrei ${name}${token?` (token:${token})`:''}`,'warn'); return false; }

  // Aviso específico para recipeIngredient em input:text
  if (token === 'schema_recipe_recipe_ingredient' && el.tagName === 'INPUT' && typeof value === 'string' && value.includes('\n')) {
    slog('aviso: recipeIngredient está em <input type="text"> — que pode não aceitar múltiplas linhas. Ideal: textarea.', 'warn');
  }
  let v = sanitizeText(value);
  if(kind==='select' || el.tagName==='SELECT'){
    const opt=[...el.options].find(o=>o.value==v) || [...el.options].find(o=>(o.textContent||'').trim()==v);
    el.value = opt ? opt.value : v;
  } else {
    el.value = (v==null?'':v);
  }
  ['input','change','blur'].forEach(t=>el.dispatchEvent(new Event(t,{bubbles:true})));
  slog(`ok → ${el.name||name} = ${v}`,'ok');
  return true;
}

function setSchemaTypeButtonsUI(active){
  const btns = [
    ['article',  $('#sch-type-article')],
    ['products', $('#sch-type-products')],
    ['recipes',  $('#sch-type-recipes')]
  ];
  btns.forEach(([type,btn])=>{
    if(!btn) return;
    if(type===active){
      btn.style.background = '#2a7';
      btn.style.color = '#111';
      btn.style.fontWeight = '600';
    } else {
      btn.style.background = '#222';
      btn.style.color = '#eee';
      btn.style.fontWeight = '400';
    }
  });
}

function setSchemaType(t){
  if(!MAPS[t]) return; // segurança
  CURRENT_SCHEMA_TYPE = t;
  setSchemaTypeButtonsUI(t);
  slog(`Schema Type: ${t}`, 'ok');
}

// Eventos dos botões
$('#sch-type-article') ?.addEventListener('click', ()=>setSchemaType('article'));
$('#sch-type-products')?.addEventListener('click', ()=>setSchemaType('products'));
$('#sch-type-recipes') ?.addEventListener('click', ()=>setSchemaType('recipes'));

// Estado inicial
setSchemaTypeButtonsUI(CURRENT_SCHEMA_TYPE);


function applySchema(){
  SLOG.textContent = '';
  const raw = $('#sch-json').value.trim();
  if (!raw) { slog('Nada para processar.','warn'); return; }

  // 1) Se o conteúdo for um dump "items", apenas atualiza o mapa e sai
  try {
    const asObj = JSON.parse(raw);
    if (asObj && Array.isArray(asObj.items)) {
      if (updateSchemaNameIndexFromItems(raw)) {
        slog('Mapa carregado. Agora cole o JSON-LD para aplicar os valores.','ok');
        return;
      }
    }
  } catch { /* pode não ser JSON puro; seguimos */ }

  // 2) Tratar como JSON-LD (com ou sem <script>)
  const jsonText = extractJsonText(raw);
  let data;
  try {
    data = JSON.parse(jsonText);
    slog('JSON válido.','ok');
  } catch (e) {
    slog('JSON inválido: ' + e.message, 'err');
    slog('Prévia: ' + jsonText.slice(0,140) + (jsonText.length>140?'…':''), 'warn');
    return;
  }

  // 3) Aplica o MAP do tipo selecionado; só reporta quando há valor e não aplicou no DOM
  const ACTIVE_MAP = MAPS[CURRENT_SCHEMA_TYPE] || [];
  const applied    = [];
  const missingDom = [];

    ACTIVE_MAP.forEach(m => {
    const valRaw = getByPath(data, m.path);
      ACTIVE_MAP.forEach(m => {
    const valRaw = getByPath(data, m.path);
    const has = valRaw !== undefined && valRaw !== null && ('' + valRaw).trim?.() !== '';
    if (!has) return;

    // --- NOVO: arrays → 1 item por linha (ex.: recipeIngredient)
    let val;
    if (Array.isArray(valRaw)) {
      const clean = s => String(s ?? '')
        .replace(/^\s*[-•\d.)]+\s*/,'') // tira bullets/numeração comuns
        .replace(/\s+/g,' ')
        .trim();
      val = valRaw.map(clean).filter(Boolean).join('\n');
    } else {
      val = valRaw;
    }

    const ok = setFieldByName(m.name, val, m.type, m.token || null);
    if (ok) applied.push(m);
    else    missingDom.push({ m, val });
  });

    // 4) Fallbacks/defaults específicos por tipo (não geram "faltando no JSON")

  // ARTICLE
  if (CURRENT_SCHEMA_TYPE === 'article') {
    // Fallback: schema_article_id ← @id || mainEntityOfPage.@id (se vazio)
    const idName = 'metatags[schema_article][schema_article_id]';
    const idEl   = findElByAny({ name:idName, token:'schema_article_id' });
    if (idEl && !idEl.value) {
      const mid = getByPath(data,'@id') || getByPath(data,'mainEntityOfPage.@id');
      if (mid) setFieldByName(idName, mid, undefined, 'schema_article_id');
    }

    // Fallback: schema_article_name ← name || headline (se vazio)
    const nameName = 'metatags[schema_article][schema_article_name]';
    const nameEl   = findElByAny({ name:nameName, token:'schema_article_name' });
    if (nameEl && !nameEl.value) {
      const nm = getByPath(data,'name') || getByPath(data,'headline');
      if (nm) setFieldByName(nameName, nm, undefined, 'schema_article_name');
    }

    // Defaults de selects
    [
      { name:'metatags[schema_article][schema_article_type]',                  expect:'Article',      type:'select', token:'schema_article_type' },
      { name:'metatags[schema_article][schema_article_image][@type]',          expect:'ImageObject',  type:'select', token:'schema_article_image.@type' },
      { name:'metatags[schema_article][schema_article_publisher][@type]',      expect:'Organization', type:'select', token:'schema_article_publisher.@type' },
      { name:'metatags[schema_article][schema_article_publisher][logo][@type]',expect:'ImageObject',  type:'select', token:'schema_article_publisher.logo.@type' },
    ].forEach(t => {
      const el = findElByAny({ name:t.name, token:t.token });
      if (el && !el.value) setFieldByName(t.name, t.expect, t.type, t.token);
    });
  }

  // PRODUCTS
  if (CURRENT_SCHEMA_TYPE === 'products') {
    // image string → image.url (se o JSON tiver "image": "https://...")
    const imageStr = getByPath(data, 'image');
    const imgUrlName = 'metatags[schema_product][schema_product_image][url]';
    const imgUrlEl   = findElByAny({ name: imgUrlName, token: 'schema_product_image.url' });
    if (imgUrlEl && !imgUrlEl.value && typeof imageStr === 'string' && imageStr.trim()) {
      setFieldByName(imgUrlName, imageStr.trim(), undefined, 'schema_product_image.url');
    }

    // Defaults de selects
    [
      { name:'metatags[schema_product][schema_product_image][@type]',           expect:'ImageObject',     type:'select', token:'schema_product_image.@type' },
      { name:'metatags[schema_product][schema_product_brand][@type]',           expect:'Organization',    type:'select', token:'schema_product_brand.@type' },
      { name:'metatags[schema_product][schema_product_aggregate_rating][@type]',expect:'AggregateRating', type:'select', token:'schema_product_aggregate_rating.@type' },
    ].forEach(t=>{
      const el = findElByAny({ name:t.name, token:t.token });
      if (el && !el.value) setFieldByName(t.name, t.expect, t.type, t.token);
    });

    // reviewCount → ratingCount (se vier assim no JSON)
    const rc = getByPath(data, 'aggregateRating.reviewCount');
    const ratingCountName = 'metatags[schema_product][schema_product_aggregate_rating][ratingCount]';
    const ratingCountEl   = findElByAny({ name: ratingCountName, token:'schema_product_aggregate_rating.ratingCount' });
    if (ratingCountEl && !ratingCountEl.value && rc != null && (''+rc).trim()) {
      setFieldByName(ratingCountName, rc, undefined, 'schema_product_aggregate_rating.ratingCount');
    }
  }

  // RECIPES
  if (CURRENT_SCHEMA_TYPE === 'recipes') {
    // recipeIngredient já vira string no loop (join '\n'), então só defaults aqui

    // Defaults de selects (autor)
    [
      { name:'metatags[schema_recipe][schema_recipe_author][@type]', expect:'Person', type:'select', token:'schema_recipe_author.@type' },
      { name:'metatags[schema_recipe][schema_recipe_type]',          expect:'Recipe', type:'select', token:'schema_recipe_type' },
    ].forEach(t=>{
      const el = findElByAny({ name:t.name, token:t.token });
      if (el && !el.value) setFieldByName(t.name, t.expect, t.type, t.token);
    });
  }


  // 5) Resumo (sem "faltando no JSON")
  if (applied.length) slog(`✅ Aplicados: ${applied.length}`, 'ok');
  if (missingDom.length) {
    slog(`⚠️ Não aplicado (campo não encontrado no DOM): ${missingDom.length}`, 'warn');
    missingDom.forEach(({ m }) => {
      slog(`  • ${m.name}  ← do JSON path "${m.path}"`, 'warn');
    });
  }
  slog('Concluído.','ok');
}

$('#sch-apply').onclick=applySchema;

/* ===================== Tabs default ===================== */
showFill();

})();
