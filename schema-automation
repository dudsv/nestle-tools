(()=>{'use strict';
// Base utils
const $=(s,c=document)=>c.querySelector(s);
const norm=s=>(s??'').toString().trim();
function setValue(el,val){ if(!el)return false; const tag=el.tagName.toLowerCase(); el.focus();
  if(tag==='input'||tag==='textarea'||tag==='select'){ el.value=(val==null?'':val); el.dispatchEvent(new Event('input',{bubbles:true})); el.dispatchEvent(new Event('change',{bubbles:true})); return true;}
  return false;
}
function clearValue(el){ return setValue(el,''); }
function pickEl(selectors){ for(const sel of selectors){ const el=$(sel); if(el) return el; } return null; }

// Default mappings (Purina + FamilyNes)
const DEFAULT_MAPPING={
// Default mappings (Purina + FamilyNes + MX)
  // H1 and URL stay the same
  h1:     [
    '#edit-title-0-value',
    '[data-drupal-selector="edit-title-0-value"]'
  ],
  url:    [
    '[data-drupal-selector="edit-path-0-alias"]',
    '#edit-path-0-alias'
  ],

  // META BASIC (Title/Description)
  // ðŸ‡²ðŸ‡½ Mexico (field_meta_tags[0]â€¦) â€” PRIORITY 1
  title:  [
    '[name="field_meta_tags[0][basic][title]"]',
    '#edit-field-meta-tags-0-basic-title',
    '[data-drupal-selector="edit-field-meta-tags-0-basic-title"]',

    // ðŸ‡ªðŸ‡º Purina/FamilyNes (ln-n-meta-tagsâ€¦) â€” fallback
    '#edit-field-ln-n-meta-tags-0-basic-title',
    '[data-drupal-selector="edit-metatags-basic-title"]'
  ],
  desc:   [
    '[name="field_meta_tags[0][basic][description]"]',
    '#edit-field-meta-tags-0-basic-description',
    '[data-drupal-selector="edit-field-meta-tags-0-basic-description"]',

    '#edit-field-ln-n-meta-tags-0-basic-description',
    '[data-drupal-selector="edit-metatags-basic-description"]'
  ],

  // OPEN GRAPH (og:title / og:description)
  ogtitle:[
    '[name="field_meta_tags[0][open_graph][og_title]"]',
    '#edit-field-meta-tags-0-open-graph-og-title',
    '[data-drupal-selector="edit-field-meta-tags-0-open-graph-og-title"]',

    '#edit-field-ln-n-meta-tags-0-open-graph-og-title',
    '[data-drupal-selector="edit-metatags-open-graph-og-title"]'
  ],
  ogdesc: [
    '[name="field_meta_tags[0][open_graph][og_description]"]',
    '#edit-field-meta-tags-0-open-graph-og-description',
    '[data-drupal-selector="edit-field-meta-tags-0-open-graph-og-description"]',

    '#edit-field-ln-n-meta-tags-0-open-graph-og-description',
    '[data-drupal-selector="edit-metatags-open-graph-og-description"]'
  ]
};


// UI
const ov=document.createElement('div');
ov.style.cssText='position:fixed;inset:0;z-index:2147483647;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center';
const bx=document.createElement('div');
bx.style.cssText='background:#111;color:#eee;width:min(1060px,96vw);max-height:94vh;overflow:auto;border-radius:14px;box-shadow:0 12px 36px rgba(0,0,0,.4);padding:16px;font:13px/1.45 system-ui,Segoe UI,Roboto,Arial';
bx.innerHTML=`
  <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:10px">
    <b style="font-size:15px">Factory Filler â€” TSV + Campos Soltos + Schema (v4.1)</b>
    <button id="ff-close" style="padding:6px 10px;border:1px solid #444;border-radius:8px;background:#222;color:#eee">Fechar</button>
  </div>

  <div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:6px">
    <button id="tab-fill"   style="padding:8px 10px;border:1px solid #444;border-radius:8px;background:#2a7;color:#111;font-weight:600">Preenchimento</button>
    <button id="tab-schema" style="padding:8px 10px;border:1px solid #444;border-radius:8px;background:#222;color:#eee">Schema</button>
  </div>

  <!-- Conventional fill pane -->
  <div id="pane-fill">
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
      <div>
        <div style="opacity:.85;margin-bottom:6px"><b>1) Linha TSV (Excel)</b> â€” cabeÃ§alho opcional (H1, Title, Desc, URL)</div>
        <textarea id="ff-tsv" placeholder="Cole aqui a LINHA TSV (1 ou 2 linhas: cabeÃ§alho + valores)" style="width:100%;height:120px;background:#181818;color:#ddd;border:1px solid #333;border-radius:10px;padding:10px"></textarea>
        <div style="margin-top:6px;opacity:.7">Se colar sÃ³ 1 linha, a ordem assumida Ã©: H1, Title, Desc, URL.</div>
      </div>

      <div>
        <div style="opacity:.85;margin-bottom:6px"><b>2) Campos Soltos (opcionais)</b> â€” sobrescrevem o TSV</div>
        <div style="display:grid;grid-template-columns:1fr;gap:8px">
          <label>H1
            <input id="ff-h1" type="text" placeholder="Ex.: Headline da pÃ¡gina" style="width:100%;background:#181818;color:#ddd;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px">
          </label>
          <label>Meta Title
            <input id="ff-title" type="text" placeholder="Ex.: Meta title" style="width:100%;background:#181818;color:#ddd;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px">
          </label>
          <label>Meta Description
            <textarea id="ff-desc" placeholder="Ex.: Meta description" style="width:100%;height:66px;background:#181818;color:#ddd;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px"></textarea>
          </label>
          <label>URL / Alias
            <input id="ff-url" type="text" placeholder="/meu-alias" style="width:100%;background:#181818;color:#ddd;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px">
          </label>

          <div style="display:flex;gap:16px;align-items:center;margin-top:6px">
            <label style="display:flex;gap:6px;align-items:center;">
              <input id="ff-sync-og-title" type="checkbox"> <span>OG Title = Meta Title</span>
            </label>
            <label style="display:flex;gap:6px;align-items:center;">
              <input id="ff-sync-og-desc" type="checkbox"> <span>OG Description = Meta Description</span>
            </label>
          </div>

          <label>OG Title
            <input id="ff-ogtitle" type="text" placeholder="(ou herdado do Meta Title)" style="width:100%;background:#181818;color:#bbb;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px">
          </label>
          <label>OG Description
            <textarea id="ff-ogdesc" placeholder="(ou herdado do Meta Description)" style="width:100%;height:66px;background:#181818;color:#bbb;border:1px solid #333;border-radius:8px;padding:8px;margin-top:4px"></textarea>
          </label>
        </div>
      </div>
    </div>

    <details style="margin-top:10px">
      <summary style="cursor:pointer;opacity:.9"><b>Opcional: Mapping JSON</b> (sobrescreve/expande seletores Purina/FamilyNes)</summary>
      <textarea id="ff-json" placeholder='Cole o JSON exportado (com "items": [...])' style="width:100%;height:120px;background:#181818;color:#ddd;border:1px solid #333;border-radius:10px;padding:10px;margin-top:8px"></textarea>
    </details>

    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="ff-run"  style="padding:10px 14px;border:1px solid #444;border-radius:10px;background:#2a7;color:#111;font-weight:600">Preencher</button>
      <button id="ff-dry"  style="padding:10px 14px;border:1px solid #444;border-radius:10px;background:#555;color:#eee;">SÃ³ simular</button>
      <button id="ff-clear"style="padding:10px 14px;border:1px solid #444;border-radius:10px;background:#222;color:#eee;">Limpar campos mapeados</button>
    </div>

    <pre id="ff-out" style="margin-top:12px;background:#0d0d0d;border:1px solid #222;border-radius:10px;padding:10px;white-space:pre-wrap"></pre>
  </div>

  <!-- Schema pane (just field + apply button, using YOUR MAP) -->
  <div id="pane-schema" style="display:none">
    <div style="opacity:.85;margin-bottom:6px"><b>Schema JSON-LD</b> â€” cole o JSON (puro) ou o bloco &lt;script type="application/ld+json"&gt;â€¦</div>
    <div id="sch-types" style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 6px">
    <button id="sch-type-article"  style="padding:6px 10px;border:1px solid #444;border-radius:8px;background:#2a7;color:#111;font-weight:600">Articles</button>
    <button id="sch-type-products" style="padding:6px 10px;border:1px solid #444;border-radius:8px;background:#222;color:#eee">Products</button>
    <button id="sch-type-recipes"  style="padding:6px 10px;border:1px solid #444;border-radius:8px;background:#222;color:#eee">Recipes</button>
    </div>

    <textarea id="sch-json" placeholder='Cole aquiâ€¦' style="width:100%;min-height:240px;background:#181818;color:#ddd;border:1px solid #333;border-radius:10px;padding:10px;"></textarea>

    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="sch-apply" style="padding:10px 14px;border:1px solid #444;border-radius:10px;background:#2a7;color:#111;font-weight:600">Aplicar Schema</button>
    </div>

    <pre id="sch-log" style="margin-top:12px;background:#0d0d0d;border:1px solid #222;border-radius:10px;padding:10px;white-space:pre-wrap;max-height:28vh;overflow:auto"></pre>
  </div>
`;
ov.appendChild(bx); document.body.appendChild(ov);
$('#ff-close').onclick=()=>ov.remove();

// Tabs
function showFill(){ $('#pane-fill').style.display=''; $('#pane-schema').style.display='none';
  $('#tab-fill').style.background='#2a7'; $('#tab-fill').style.color='#111';
  $('#tab-schema').style.background='#222'; $('#tab-schema').style.color='#eee';
}
function showSchema(){ $('#pane-fill').style.display='none'; $('#pane-schema').style.display='';
  $('#tab-schema').style.background='#2a7'; $('#tab-schema').style.color='#111';
  $('#tab-fill').style.background='#222'; $('#tab-fill').style.color='#eee';
}
$('#tab-fill').onclick=showFill; $('#tab-schema').onclick=showSchema;

// Fill (TSV + Fields)
function parseTSV(text){
  const lines=norm(text).split(/\r?\n/).filter(Boolean);
  if(!lines.length) return {};
  let headers=[],values=[];
  if(lines.length===1){ values=lines[0].split('\t'); headers=['H1','Title','Desc','URL']; }
  else{ headers=lines[0].split('\t'); values=lines[1].split('\t'); }
  const raw={}; headers.forEach((h,i)=>raw[h.trim()]=(values[i]||'').trim());
  const out={};
  for(const [k,v] of Object.entries(raw)){
    const kk=k.toLowerCase();
    if(/(^|\s)h1($|\s)/.test(kk)) out.h1=v;
    else if(kk.includes('meta title')||kk==='title') out.title=v;
    else if(kk.includes('meta description')||kk==='desc'||kk==='description') out.desc=v;
    else if(kk==='url'||kk==='alias'||kk==='path'||kk==='slug') out.url=v;
    else if(kk.includes('og')&&kk.includes('title')) out.ogtitle=v;
    else if(kk.includes('og')&&(kk.includes('desc')||kk.includes('description'))) out.ogdesc=v;
  }
  return out;
}
function getManualValues(){return{
  h1:norm($('#ff-h1').value), title:norm($('#ff-title').value), desc:norm($('#ff-desc').value),
  url:norm($('#ff-url').value), ogtitle:norm($('#ff-ogtitle').value), ogdesc:norm($('#ff-ogdesc').value)
};}
function mergePayload(tsv,man,syncT,syncD){ const p={...tsv};
  for(const k of ['h1','title','desc','url','ogtitle','ogdesc']) if(man[k]) p[k]=man[k];
  if(syncT) p.ogtitle=p.title||''; if(syncD) p.ogdesc=p.desc||'';
  return p;
}
function buildSelectorPoolFromJSON(jsonText){
  const pool=JSON.parse(JSON.stringify(DEFAULT_MAPPING));
  if(!jsonText||!jsonText.trim()) return pool;
  try{
    const data=JSON.parse(jsonText); const items=Array.isArray(data.items)?data.items:[];
    const push=(key,sel)=>{ if(sel && !pool[key].includes(sel)) pool[key].push(sel); };
    for(const it of items){
      const label=(it.field?.label||'').toLowerCase(); const note=(it.note||'').toLowerCase();
      const sel=it.field?.cssSelector||(it.field?.id?('#'+it.field.id):null); if(!sel) continue;
      if(note.includes('recebe o h1')||['titulo','tÃ­tulo','title'].includes(label)) push('h1',sel);
if(note.includes('meta title')||label==='page title'||note.trim()==='title') push('title',sel);
if(note.includes('meta description')||label==='description'||note.trim()==='desc') push('desc',sel);
if(note.includes('og title')||note.trim()==='ogtitle') push('ogtitle',sel);
if(note.includes('og description')||note.trim()==='ogdesc') push('ogdesc',sel);
if(label.includes('alias')||note.includes('alias')||note.includes('url')) push('url',sel);

    }
  }catch{}
  return pool;
}
function fillFields(payload,selectorPool,{dryRun=false,doClear=false}={}){
  const report={filled:[],skipped:[],missing:[]};
  const keys=['h1','title','desc','ogtitle','ogdesc','url'];
  for(const key of keys){
    const sels=selectorPool[key]||[]; const el=pickEl(sels);
    const hasVal=Object.prototype.hasOwnProperty.call(payload,key)&&payload[key]!==''&&payload[key]!=null;
    const labelHint=(sels[0]||'(nenhum)');
    if(!el){ if(hasVal) report.missing.push({key,selector:labelHint}); continue; }
    if(doClear && !hasVal){ if(!dryRun) clearValue(el); report.filled.push({key,selector:labelHint,value:''}); continue; }
    if(hasVal){ if(!dryRun) setValue(el,payload[key]); report.filled.push({key,selector:labelHint,value:payload[key]}); }
    else{ report.skipped.push({key,selector:labelHint}); }
  }
  return report;
}
function fmtReport(rep){
  const L=[];
  if(rep.filled.length){ L.push('âœ… Preenchidos:'); rep.filled.forEach(x=>L.push(`  â€¢ ${x.key} â†’ ${x.selector}\n    â†³ ${x.value}`)); }
  if(rep.skipped.length){ L.push('\nâ­ï¸ Ignorados (sem valor):'); rep.skipped.forEach(x=>L.push(`  â€¢ ${x.key} â†’ ${x.selector}`)); }
  if(rep.missing.length){ L.push('\nâš ï¸ Campo nÃ£o encontrado (nenhum seletor vÃ¡lido no DOM):'); rep.missing.forEach(x=>L.push(`  â€¢ ${x.key} (ex.: ${x.selector})`)); }
  return L.join('\n');
}
const outEl=$('#ff-out');
const titleEl=$('#ff-title'),descEl=$('#ff-desc'),ogtEl=$('#ff-ogtitle'),ogdEl=$('#ff-ogdesc'),cSyncT=$('#ff-sync-og-title'),cSyncD=$('#ff-sync-og-desc');
function syncOGTitle(){ if(cSyncT.checked){ ogtEl.value=titleEl.value; ogtEl.disabled=true; ogtEl.style.opacity=.6; } else { ogtEl.disabled=false; ogtEl.style.opacity=1; } }
function syncOGDesc(){ if(cSyncD.checked){ ogdEl.value=descEl.value; ogdEl.disabled=true; ogdEl.style.opacity=.6; } else { ogdEl.disabled=false; ogdEl.style.opacity=1; } }
cSyncT.addEventListener('change',syncOGTitle); cSyncD.addEventListener('change',syncOGDesc);
titleEl.addEventListener('input',syncOGTitle); descEl.addEventListener('input',syncOGDesc);
syncOGTitle(); syncOGDesc();

function getPayloadAndMap(){ const tsv=parseTSV($('#ff-tsv').value); const manual=getManualValues();
  const data=mergePayload(tsv,manual,cSyncT.checked,cSyncD.checked);
  const pool=buildSelectorPoolFromJSON($('#ff-json').value);
  return {data,pool};
}
$('#ff-run').onclick=()=>{ const {data,pool}=getPayloadAndMap(); const rep=fillFields(data,pool,{dryRun:false}); outEl.textContent=fmtReport(rep); };
$('#ff-dry').onclick=()=>{ const {data,pool}=getPayloadAndMap(); const rep=fillFields(data,pool,{dryRun:true}); outEl.textContent='[SimulaÃ§Ã£o]\n'+fmtReport(rep); };
$('#ff-clear').onclick=()=>{ const {pool}=getPayloadAndMap(); const rep=fillFields({},pool,{doClear:true}); outEl.textContent='[Limpeza]\n'+fmtReport(rep); };

// Schema (using your MAP and setField by name=)
const SLOG=$('#sch-log');
// Schema Name Index (supports "items" dumps)
let SCHEMA_NAME_INDEX = Object.create(null); // token -> { name, css, id }

function normalizeToken(tokens) {
  // tokens -> anchor in schema_article | schema_product | schema_recipe and return the rest as token
  if (!Array.isArray(tokens)) return null;
  let i = tokens.indexOf('schema_article');
  if (i < 0) i = tokens.indexOf('schema_product');
  if (i < 0) i = tokens.indexOf('schema_recipe');
  if (i < 0) i = 0;
  const slice = tokens.slice(i);
  if (slice.length >= 2) {
    const head = (slice[0] === 'schema_article' || slice[0] === 'schema_product' || slice[0] === 'schema_recipe')
      ? slice.slice(1) : slice;
    return head.join('.'); // e.g., "schema_recipe_author.@type"
  }
  return null;
}


function updateSchemaNameIndexFromItems(jsonText) {
  try {
    const data = JSON.parse(jsonText);
    if (!data || !Array.isArray(data.items)) return false;
    let count = 0;
    data.items.forEach(it => {
      const name = it?.field?.name;
      const css  = it?.field?.cssSelector || it?.field?.wrapperSelector;
      const id   = it?.field?.id;
      const tokens = it?.drupal?.nameTokens;
      const token = normalizeToken(tokens);
      if (token && (name || css)) {
        SCHEMA_NAME_INDEX[token] = { name, css, id };
        count++;
      }
    });
    slog(`Mapa de Schema/Meta carregado (${count} itens).`, 'ok');
    return count > 0;
  } catch (e) {
    return false;
  }
}

// Try name variants (metatags[...] -> field_meta_tags[0][...])
function guessNameVariant(originalName) {
  if (!originalName) return null;
  // ex: metatags[schema_article][schema_article_type]
  // -> field_meta_tags[0][schema_article][schema_article_type]
  const m = originalName.match(/^metatags\[(.+?)\]\[(.+?)\]$/) ||
            originalName.match(/^metatags\[(.+?)\]\[(.+?)\]\[(.+?)\]$/) ||
            originalName.match(/^metatags\[(.+?)\]\[(.+?)\]\[(.+?)\]\[(.+?)\]$/);
  if (!m) return null;
  const parts = originalName
    .replace(/^metatags\[/, 'field_meta_tags[0][')
    .replace(/\]\[/g, '][');
  return parts;
}

// Find element by: exact name â†’ name variant â†’ CSS from token â†’ id â†’ fallback endsWith
function findElByAny({ name, token }) {
  let sel, el;
  if (name) {
    sel = `[name="${name.replace(/"/g, '\\"')}"]`;
    el = document.querySelector(sel);
    if (el) return el;

    const v = guessNameVariant(name);
    if (v) {
      sel = `[name="${v.replace(/"/g, '\\"')}"]`;
      el = document.querySelector(sel);
      if (el) return el;
    }
  }
  if (token && SCHEMA_NAME_INDEX[token]) {
    const info = SCHEMA_NAME_INDEX[token];
    if (info.name) {
      sel = `[name="${info.name.replace(/"/g, '\\"')}"]`;
      el = document.querySelector(sel);
      if (el) return el;
    }
    if (info.css) {
      el = document.querySelector(info.css);
      if (el) return el;
    }
    if (info.id) {
      el = document.getElementById(info.id);
      if (el) return el;
    }
  }
  // fallback: any input/select whose name ends with the original suffix
  if (name) {
    const short = name.replace(/^metatags\[/, '').replace(/\]$/,'');
    const candidates = document.querySelectorAll('input[name],textarea[name],select[name]');
    for (const c of candidates) {
      if ((c.name || '').endsWith(short)) return c;
    }
  }
  return null;
}

const slog=(m,cls='')=>{ SLOG.textContent+= (cls?`[${cls}] `:'') + m + '\n'; SLOG.scrollTop=SLOG.scrollHeight; };

// Your snippet functions (adapted only to use local IDs)
const APP_ID='schema-json-fill'; // just to keep names

// Current schema type (Article, Products, Recipes)
let CURRENT_SCHEMA_TYPE = 'article';

// Schema types enum (to avoid typos)
const SCHEMA_TYPES = {
  ARTICLE:  'article',
  PRODUCTS: 'products',
  RECIPES:  'recipes',
};

// MAP: Article (yours, intact)
const ARTICLE_MAP = [
  { path:'@type',                  name:'metatags[schema_article][schema_article_type]',                          type:'select', token:'schema_article_type' },
  { path:'mainEntityOfPage.@id',   name:'metatags[schema_article][schema_article_main_entity_of_page]',                                token:'schema_article_main_entity_of_page' },
  { path:'headline',               name:'metatags[schema_article][schema_article_headline]',                                           token:'schema_article_headline' },
  { path:'description',            name:'metatags[schema_article][schema_article_description]',                                        token:'schema_article_description' },
  { path:'image.@type',            name:'metatags[schema_article][schema_article_image][@type]',                type:'select',          token:'schema_article_image.@type' },
  { path:'image.url',              name:'metatags[schema_article][schema_article_image][url]',                                        token:'schema_article_image.url' },
  { path:'datePublished',          name:'metatags[schema_article][schema_article_date_published]',                                    token:'schema_article_date_published' },
  { path:'publisher.@type',        name:'metatags[schema_article][schema_article_publisher][@type]',           type:'select',          token:'schema_article_publisher.@type' },
  { path:'publisher.name',         name:'metatags[schema_article][schema_article_publisher][name]',                                    token:'schema_article_publisher.name' },
  { path:'publisher.logo.@type',   name:'metatags[schema_article][schema_article_publisher][logo][@type]',     type:'select',          token:'schema_article_publisher.logo.@type' },
  { path:'publisher.logo.url',     name:'metatags[schema_article][schema_article_publisher][logo][url]',                               token:'schema_article_publisher.logo.url' },

  // optional + fallbacks
  { path:'@id',                    name:'metatags[schema_article][schema_article_id]',                                                 token:'schema_article_id' },
  { path:'name',                   name:'metatags[schema_article][schema_article_name]',                                               token:'schema_article_name' },
];

// MAP: Products (from your dump)
const PRODUCTS_MAP = [
  // root
  { path:'@type',        name:'metatags[schema_product][schema_product_type]',                                   type:'select', token:'schema_product_type' },
  { path:'name',         name:'metatags[schema_product][schema_product_name]',                                                  token:'schema_product_name' },
  { path:'description',  name:'metatags[schema_product][schema_product_description]',                                           token:'schema_product_description' },
  { path:'url',          name:'metatags[schema_product][schema_product_url]',                                                   token:'schema_product_url' },

  // image
  { path:'image.@type',  name:'metatags[schema_product][schema_product_image][@type]',                       type:'select',     token:'schema_product_image.@type' },
  { path:'image.url',    name:'metatags[schema_product][schema_product_image][url]',                                          token:'schema_product_image.url' },

  // brand
  { path:'brand.@type',  name:'metatags[schema_product][schema_product_brand][@type]',                       type:'select',     token:'schema_product_brand.@type' },
  { path:'brand.name',   name:'metatags[schema_product][schema_product_brand][name]',                                         token:'schema_product_brand.name' },

  // aggregateRating
  { path:'aggregateRating.@type',       name:'metatags[schema_product][schema_product_aggregate_rating][@type]', type:'select', token:'schema_product_aggregate_rating.@type' },
  { path:'aggregateRating.ratingValue', name:'metatags[schema_product][schema_product_aggregate_rating][ratingValue]',        token:'schema_product_aggregate_rating.ratingValue' },
  { path:'aggregateRating.ratingCount', name:'metatags[schema_product][schema_product_aggregate_rating][ratingCount]',        token:'schema_product_aggregate_rating.ratingCount' },
];

// MAP: Recipes
const RECIPES_MAP = [
  // root
  { path:'@type',           name:'metatags[schema_recipe][schema_recipe_type]',                 type:'select', token:'schema_recipe_type' },
  { path:'name',            name:'metatags[schema_recipe][schema_recipe_name]',                               token:'schema_recipe_name' },
  { path:'description',     name:'metatags[schema_recipe][schema_recipe_description]',                        token:'schema_recipe_description' },
  { path:'datePublished',   name:'metatags[schema_recipe][schema_recipe_date_published]',                     token:'schema_recipe_date_published' },

  // ingredients (array in JSON)
  { path:'recipeIngredient', name:'metatags[schema_recipe][schema_recipe_recipe_ingredient]',                 token:'schema_recipe_recipe_ingredient' },

  // author
  { path:'author.@type',    name:'metatags[schema_recipe][schema_recipe_author][@type]',        type:'select', token:'schema_recipe_author.@type' },
  { path:'author.name',     name:'metatags[schema_recipe][schema_recipe_author][name]',                      token:'schema_recipe_author.name' },

  // instructions (long string)
  { path:'recipeInstructions', name:'metatags[schema_recipe][schema_recipe_recipe_instructions]',            token:'schema_recipe_recipe_instructions' },
];


// Final maps dictionary by type
const MAPS = {
  [SCHEMA_TYPES.ARTICLE]:  ARTICLE_MAP,
  [SCHEMA_TYPES.PRODUCTS]: PRODUCTS_MAP,
  [SCHEMA_TYPES.RECIPES]:  RECIPES_MAP,
};

function sanitizeText(v){ if(typeof v!=='string') return v;
  return v.replace(/[\u201C\u201D\u201E\u201F\u2033]/g,'"').replace(/[\u2018\u2019\u2032]/g,"'")
    .replace(/\s+/g,' ').replace(/^\s*["â€œ]|["â€]\s*$/g,'').trim();
}
function getByPath(obj,path){ if(!obj||!path) return undefined; return path.split('.').reduce((acc,key)=>acc&&acc[key],obj); }

// Extract JSON from textarea (accepts ld+json <script> and CSV with double quotes)
function extractJsonText(raw){
  let txt=(raw||'').trim().replace(/^\uFEFF/,'');
  if(txt.startsWith('"')&&txt.endsWith('"')){ const inner=txt.slice(1,-1); if((inner.match(/""/g)||[]).length>=1){ txt=inner.replace(/""/g,'"'); slog('Detectei CSV/Excel com aspas â€” normalizado.','ok'); } }
  if(/<script[^>]*application\/ld\+json/i.test(txt)){
    const m=txt.match(/<script[^>]*application\/ld\+json[^>]*>([\s\S]*?)<\/script>/i);
    if(m&&m[1]){ txt=m[1].trim(); slog('Removi wrapper <script type="application/ld+json">.','ok'); }
    else{ try{ const doc=new DOMParser().parseFromString(txt,'text/html'); const el=doc.querySelector('script[type="application/ld+json"]'); if(el&&el.textContent){ txt=el.textContent.trim(); slog('ExtraÃ­ JSON-LD via DOMParser.','ok'); } }catch{}
    }
  }
  return txt.trim();
}

function setFieldByName(name, value, kind, token=null){
  const el = findElByAny({ name, token });
  if(!el){ slog(`nÃ£o encontrei ${name}${token?` (token:${token})`:''}`,'warn'); return false; }

  // Specific warning for recipeIngredient in input:text
  if (token === 'schema_recipe_recipe_ingredient' && el.tagName === 'INPUT' && typeof value === 'string' && value.includes('\n')) {
    slog('aviso: recipeIngredient estÃ¡ em <input type="text"> â€” que pode nÃ£o aceitar mÃºltiplas linhas. Ideal: textarea.', 'warn');
  }
  let v = sanitizeText(value);
  if(kind==='select' || el.tagName==='SELECT'){
    const opt=[...el.options].find(o=>o.value==v) || [...el.options].find(o=>(o.textContent||'').trim()==v);
    el.value = opt ? opt.value : v;
  } else {
    el.value = (v==null?'':v);
  }
  ['input','change','blur'].forEach(t=>el.dispatchEvent(new Event(t,{bubbles:true})));
  slog(`ok â†’ ${el.name||name} = ${v}`,'ok');
  return true;
}

// FamilyNes: token presets + domain guard
const IS_FAMILYNES = /\.?familynes\./i.test(location.hostname);

// FamilyNes presets for Article + WebPage Publisher (if present)
const FN_SCHEMA_PRESETS = {
  article: [
    // Article
    ['metatags[schema_article][schema_article_type]', 'Article', 'select', 'schema_article_type'],
    ['metatags[schema_article][schema_article_id]', '[current-page:url]', null, 'schema_article_id'],
    ['metatags[schema_article][schema_article_headline]', '[current-page:metatag:title]', null, 'schema_article_headline'],
    ['metatags[schema_article][schema_article_description]', '[node:field_np_teaser_text]', null, 'schema_article_description'],
    ['metatags[schema_article][schema_article_date_published]', '[node:created:metatag_datetime]', null, 'schema_article_date_published'],
    // If your build has "date modified" (many do):
    ['metatags[schema_article][schema_article_date_modified]', '[node:revision-created:metatag_datetime]', null, 'schema_article_date_modified'],
    ['metatags[schema_article][schema_article_main_entity_of_page]', '[node:url]', null, 'schema_article_main_entity_of_page'],

    // ImageObject (uses site logo as representative)
    ['metatags[schema_article][schema_article_image][@type]', 'ImageObject', 'select', 'schema_article_image.@type'],
    ['metatags[schema_article][schema_article_image][url]', '[cp:site-logo-url]', null, 'schema_article_image.url'],

    // Author = Organization
    ['metatags[schema_article][schema_article_author][@type]', 'Organization', 'select', 'schema_article_author.@type'],
    ['metatags[schema_article][schema_article_author][name]', '[site:name]', null, 'schema_article_author.name'],
    ['metatags[schema_article][schema_article_author][url]',  '[site:url]',  null, 'schema_article_author.url'],

    // Publisher = Organization + Logo
    ['metatags[schema_article][schema_article_publisher][@type]', 'Organization', 'select', 'schema_article_publisher.@type'],
    ['metatags[schema_article][schema_article_publisher][name]', '[site:name]', null, 'schema_article_publisher.name'],
    ['metatags[schema_article][schema_article_publisher][url]',  '[site:url]',  null, 'schema_article_publisher.url'],
    ['metatags[schema_article][schema_article_publisher][logo][@type]', 'ImageObject', 'select', 'schema_article_publisher.logo.@type'],
    ['metatags[schema_article][schema_article_publisher][logo][url]', '[cp:site-logo-url]', null, 'schema_article_publisher.logo.url'],

    // (Optional) WebPage Publisher (if present in your build)
    ['metatags[schema_web_page][schema_web_page_publisher][@type]', 'Organization', 'select', 'schema_web_page_publisher.@type'],
    ['metatags[schema_web_page][schema_web_page_publisher][name]', '[site:name]', null, 'schema_web_page_publisher.name'],
    ['metatags[schema_web_page][schema_web_page_publisher][url]',  '[site:url]',  null, 'schema_web_page_publisher.url'],
    ['metatags[schema_web_page][schema_web_page_publisher][logo][@type]', 'ImageObject', 'select', 'schema_web_page_publisher.logo.@type'],
    ['metatags[schema_web_page][schema_web_page_publisher][logo][url]', '[cp:site-logo-url]', null, 'schema_web_page_publisher.logo.url'],
  ],
};

// Apply FamilyNes tokens only on familynes.xx domain
function applyFamilyNesTokens({ force = false } = {}) {
  if (!IS_FAMILYNES) return; // only runs on FamilyNes
  const rows = FN_SCHEMA_PRESETS.article;
  rows.forEach(([name, value, kind, token]) => {
    const el = findElByAny({ name, token });
    if (!el) { slog?.(`familynes: campo ausente â†’ ${name}`, 'warn'); return; }
    // by default, fill only if empty; with force=true overwrite
    if (force || !el.value) setFieldByName(name, value, kind, token);
  });
  slog?.('familynes: tokens padrÃ£o aplicados.', 'ok');
}
// Apply FamilyNes tokens when loading the map

function setSchemaTypeButtonsUI(active){
  const btns = [
    ['article',  $('#sch-type-article')],
    ['products', $('#sch-type-products')],
    ['recipes',  $('#sch-type-recipes')]
  ];
  btns.forEach(([type,btn])=>{
    if(!btn) return;
    if(type===active){
      btn.style.background = '#2a7';
      btn.style.color = '#111';
      btn.style.fontWeight = '600';
    } else {
      btn.style.background = '#222';
      btn.style.color = '#eee';
      btn.style.fontWeight = '400';
    }
  });
}

function setSchemaType(t){
  if(!MAPS[t]) return; // safety
  CURRENT_SCHEMA_TYPE = t;
  setSchemaTypeButtonsUI(t);
  slog(`Schema Type: ${t}`, 'ok');
}

// Buttons events
const _btnArticle  = $('#sch-type-article');
const _btnProducts = $('#sch-type-products');
const _btnRecipes  = $('#sch-type-recipes');

if (_btnArticle)  _btnArticle.addEventListener('click',  ()=>setSchemaType('article'));
if (_btnProducts) _btnProducts.addEventListener('click', ()=>setSchemaType('products'));
if (_btnRecipes)  _btnRecipes.addEventListener('click',  ()=>setSchemaType('recipes'));
// Initial state
setSchemaTypeButtonsUI(CURRENT_SCHEMA_TYPE);



function applySchema(){
  SLOG.textContent = '';
  const raw = $('#sch-json').value.trim();
  if (!raw) { slog('Nada para processar.','warn'); return; }

  // 1) If content is an "items" dump, only update the map and exit
  try {
    const asObj = JSON.parse(raw);
    if (asObj && Array.isArray(asObj.items)) {
      if (updateSchemaNameIndexFromItems(raw)) {
        slog('Mapa carregado. Agora cole o JSON-LD para aplicar os valores.','ok');
        return;
      }
    }
  } catch { /* may not be pure JSON; continue */ }

  // 2) Treat as JSON-LD (with or without <script>)
  const jsonText = extractJsonText(raw);
  let data;
  try {
    data = JSON.parse(jsonText);
    slog('JSON vÃ¡lido.','ok');
  } catch (e) {
    slog('JSON invÃ¡lido: ' + e.message, 'err');
    slog('PrÃ©via: ' + jsonText.slice(0,140) + (jsonText.length>140?'â€¦':''), 'warn');
    return;
  }

  // 3) Apply the MAP of the selected type; only report when there is a value and it was not applied in the DOM
const ACTIVE_MAP = MAPS[CURRENT_SCHEMA_TYPE] || [];
const applied    = [];
const missingDom = [];

ACTIVE_MAP.forEach(m => {
  const valRaw = getByPath(data, m.path);
  const has = valRaw !== undefined && valRaw !== null && ('' + valRaw).trim?.() !== '';
  if (!has) return;

  // arrays â†’ 1 item per line (e.g., recipeIngredient)
  let val;
  if (Array.isArray(valRaw)) {
    const clean = s => String(s ?? '')
      .replace(/^\s*[-â€¢\d.)]+\s*/,'') // remove common bullets/numbering
      .replace(/\s+/g,' ')
      .trim();
    val = valRaw.map(clean).filter(Boolean).join('\n');
  } else {
    val = valRaw;
  }

  const ok = setFieldByName(m.name, val, m.type, m.token || null);
  if (ok) applied.push(m);
  else    missingDom.push({ m, val });
});

    // 4) Type-specific fallbacks/defaults (do not generate â€œmissing in JSONâ€)

  // ARTICLE
  if (CURRENT_SCHEMA_TYPE === 'article') {
    // Fallback: schema_article_id â† @id || mainEntityOfPage.@id (if empty)
    const idName = 'metatags[schema_article][schema_article_id]';
    const idEl   = findElByAny({ name:idName, token:'schema_article_id' });
    if (idEl && !idEl.value) {
      const mid = getByPath(data,'@id') || getByPath(data,'mainEntityOfPage.@id');
      if (mid) setFieldByName(idName, mid, undefined, 'schema_article_id');
    }

    // Fallback: schema_article_name â† name || headline (if empty)
    const nameName = 'metatags[schema_article][schema_article_name]';
    const nameEl   = findElByAny({ name:nameName, token:'schema_article_name' });
    if (nameEl && !nameEl.value) {
      const nm = getByPath(data,'name') || getByPath(data,'headline');
      if (nm) setFieldByName(nameName, nm, undefined, 'schema_article_name');
    }

    // Select defaults
    [
      { name:'metatags[schema_article][schema_article_type]',                  expect:'Article',      type:'select', token:'schema_article_type' },
      { name:'metatags[schema_article][schema_article_image][@type]',          expect:'ImageObject',  type:'select', token:'schema_article_image.@type' },
      { name:'metatags[schema_article][schema_article_publisher][@type]',      expect:'Organization', type:'select', token:'schema_article_publisher.@type' },
      { name:'metatags[schema_article][schema_article_publisher][logo][@type]',expect:'ImageObject',  type:'select', token:'schema_article_publisher.logo.@type' },
    ].forEach(t => {
      const el = findElByAny({ name:t.name, token:t.token });
      if (el && !el.value) setFieldByName(t.name, t.expect, t.type, t.token);
    });
  }

  // PRODUCTS
  if (CURRENT_SCHEMA_TYPE === 'products') {
    // image string â†’ image.url (if JSON has "image": "https://...")
    const imageStr = getByPath(data, 'image');
    const imgUrlName = 'metatags[schema_product][schema_product_image][url]';
    const imgUrlEl   = findElByAny({ name: imgUrlName, token: 'schema_product_image.url' });
    if (imgUrlEl && !imgUrlEl.value && typeof imageStr === 'string' && imageStr.trim()) {
      setFieldByName(imgUrlName, imageStr.trim(), undefined, 'schema_product_image.url');
    }

    // Select defaults
    [
      { name:'metatags[schema_product][schema_product_image][@type]',           expect:'ImageObject',     type:'select', token:'schema_product_image.@type' },
      { name:'metatags[schema_product][schema_product_brand][@type]',           expect:'Organization',    type:'select', token:'schema_product_brand.@type' },
      { name:'metatags[schema_product][schema_product_aggregate_rating][@type]',expect:'AggregateRating', type:'select', token:'schema_product_aggregate_rating.@type' },
    ].forEach(t=>{
      const el = findElByAny({ name:t.name, token:t.token });
      if (el && !el.value) setFieldByName(t.name, t.expect, t.type, t.token);
    });

    // reviewCount â†’ ratingCount (if it comes like this in JSON)
    const rc = getByPath(data, 'aggregateRating.reviewCount');
    const ratingCountName = 'metatags[schema_product][schema_product_aggregate_rating][ratingCount]';
    const ratingCountEl   = findElByAny({ name: ratingCountName, token:'schema_product_aggregate_rating.ratingCount' });
    if (ratingCountEl && !ratingCountEl.value && rc != null && (''+rc).trim()) {
      setFieldByName(ratingCountName, rc, undefined, 'schema_product_aggregate_rating.ratingCount');
    }
  }

  // RECIPES
  if (CURRENT_SCHEMA_TYPE === 'recipes') {
    // recipeIngredient already becomes a string in the loop (join '\n'), so only defaults here

    // Select defaults (author)
    [
      { name:'metatags[schema_recipe][schema_recipe_author][@type]', expect:'Person', type:'select', token:'schema_recipe_author.@type' },
      { name:'metatags[schema_recipe][schema_recipe_type]',          expect:'Recipe', type:'select', token:'schema_recipe_type' },
    ].forEach(t=>{
      const el = findElByAny({ name:t.name, token:t.token });
      if (el && !el.value) setFieldByName(t.name, t.expect, t.type, t.token);
    });
  }


  // 5) Summary (no â€œmissing in JSONâ€)
  if (applied.length) slog(`âœ… Aplicados: ${applied.length}`, 'ok');
  if (missingDom.length) {
    slog(`âš ï¸ NÃ£o aplicado (campo nÃ£o encontrado no DOM): ${missingDom.length}`, 'warn');
    missingDom.forEach(({ m }) => {
      slog(`  â€¢ ${m.name}  â† do JSON path "${m.path}"`, 'warn');
    });
  }
  slog('ConcluÃ­do.','ok');
}

$('#sch-apply').onclick=applySchema;

// Manual button: "Apply tokens (FamilyNes)"
(function mountApplyTokensButton(){
  const anchor = document.querySelector('#sch-apply'); // existing "Aplicar Schema" button
  if (!anchor) { console.warn('Schema: base button not found to anchor "Aplicar tokens".'); return; }
  if (document.getElementById('sch-apply-fn')) return; // already mounted

  const btn = document.createElement('button');
  btn.id = 'sch-apply-fn';
  btn.type = 'button';
  btn.textContent = 'Aplicar tokens (FamilyNes)';
  // inherit anchor style (simple fallback)
  btn.setAttribute('style', anchor.getAttribute('style') || 'padding:10px 14px;border:1px solid #444;border-radius:10px;background:#555;color:$eee;');
  btn.style.marginLeft = '8px';
  btn.title = 'Dica: Shift+Clique para FORÃ‡AR (sobrescrever)';

  btn.addEventListener('click', (ev) => {
    if (!IS_FAMILYNES) { alert('NÃ£o Ã© um domÃ­nio FamilyNes. Nada serÃ¡ aplicado.'); return; }
    if ((CURRENT_SCHEMA_TYPE || '').toLowerCase() !== 'article') { alert('Selecione o tipo: Articles.'); return; }
    // Shift+Click => force:true
    const force = !!ev.shiftKey;
    applyFamilyNesTokens({ force });
  });

  // place next to "Aplicar Schema"
  anchor.insertAdjacentElement('afterend', btn);
})();

// Tabs default
showFill();

})();
